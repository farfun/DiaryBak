<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        <meta name="author" content="NiuLiangtao">
        <link rel="canonical" href="https://1007530194.github.io/Diary/学习/转载/cs231n-ch/ch-neural-networks-2/">
        <link rel="shortcut icon" href="../../../../img/favicon.ico">
        <title>neural-networks-2 - Blog of NiuLiangtao</title>
        <link href="../../../../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../../../../css/font-awesome-4.5.0.css" rel="stylesheet">
        <link href="../../../../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="../../../../css/highlight.css">
        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

        <script src="../../../../js/jquery-1.10.2.min.js"></script>
        <script src="../../../../js/bootstrap-3.0.3.min.js"></script>
        <script src="../../../../js/highlight.pack.js"></script> 
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="../../../../ToDo/">Blog of NiuLiangtao</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
                <!-- Main navigation -->
                <ul class="nav navbar-nav">
                    <li >
                        <a href="../../../../ToDo/">Home</a>
                    </li>
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Home <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                            
<li >
    <a href="../../../../AboutMe/">About</a>
</li>
                            
<li >
    <a href="../../../..">Home</a>
</li>
                            
<li >
    <a href="../../../../Nothing/">Nothing</a>
</li>
                            
<li >
    <a href="../../../../ToDo/">要做的</a>
</li>
                        </ul>
                    </li>
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">书籍 <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                            
<li >
    <a href="../../../../书籍/">Home</a>
</li>
                            
  <li class="dropdown-submenu">
    <a href="#">机器学习实战</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../../../../书籍/机器学习实战/00naive-bayes-discuss/">naive-bayes-discuss</a>
</li>
            
<li >
    <a href="../../../../书籍/机器学习实战/01.机器学习基础/">1.机器学习基础</a>
</li>
            
<li >
    <a href="../../../../书籍/机器学习实战/02.k-近邻算法/">2.k-近邻算法</a>
</li>
            
<li >
    <a href="../../../../书籍/机器学习实战/03.决策树/">3.决策树</a>
</li>
            
<li >
    <a href="../../../../书籍/机器学习实战/04.朴素贝叶斯/">4.朴素贝叶斯</a>
</li>
            
<li >
    <a href="../../../../书籍/机器学习实战/05.Logistic回归/">5.Logistic回归</a>
</li>
            
<li >
    <a href="../../../../书籍/机器学习实战/06.0.支持向量机/">6.支持向量机</a>
</li>
            
<li >
    <a href="../../../../书籍/机器学习实战/06.1.支持向量机的几个通俗理解/">6.1.支持向量机的几个通俗理解</a>
</li>
            
<li >
    <a href="../../../../书籍/机器学习实战/07.集成方法-随机森林和AdaBoost/">7.集成方法-随机森林和AdaBoost</a>
</li>
            
<li >
    <a href="../../../../书籍/机器学习实战/08.预测数值型数据-回归/">8.预测数值型数据：回归</a>
</li>
            
<li >
    <a href="../../../../书籍/机器学习实战/09.树回归/">9.树回归</a>
</li>
            
<li >
    <a href="../../../../书籍/机器学习实战/10.k-means聚类/">10.k-means聚类</a>
</li>
            
<li >
    <a href="../../../../书籍/机器学习实战/11.使用Apriori算法进行关联分析/">11.使用Apriori算法进行关联分析</a>
</li>
            
<li >
    <a href="../../../../书籍/机器学习实战/12.使用FP-growth算法来高效发现频繁项集/">12.使用FP-growth算法来高效发现频繁项集</a>
</li>
            
<li >
    <a href="../../../../书籍/机器学习实战/13.利用PCA来简化数据/">13.利用PCA来简化数据</a>
</li>
            
<li >
    <a href="../../../../书籍/机器学习实战/14.利用SVD简化数据/">14.利用SVD简化数据</a>
</li>
            
<li >
    <a href="../../../../书籍/机器学习实战/15.大数据与MapReduce/">15.大数据与MapReduce</a>
</li>
            
<li >
    <a href="../../../../书籍/机器学习实战/16.推荐系统/">16.推荐系统</a>
</li>
    </ul>
  </li>
                            
  <li class="dropdown-submenu">
    <a href="#">深度学习</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../../../../书籍/深度学习/DeepLearning/">深度学习中文版</a>
</li>
    </ul>
  </li>
                        </ul>
                    </li>
                    <li class="dropdown active">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">学习 <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                            
<li >
    <a href="../../../">Home</a>
</li>
                            
  <li class="dropdown-submenu">
    <a href="#">tensorflow</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../../../tensorflow/如何选择优化器 optimizer/">如何选择优化器 optimizer</a>
</li>
    </ul>
  </li>
                            
  <li class="dropdown-submenu">
    <a href="#">深度学习</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../../../深度学习/主成分分析-2/">主成分分析 (2)</a>
</li>
            
<li >
    <a href="../../../深度学习/主成分分析/">主成分分析</a>
</li>
            
<li >
    <a href="../../../深度学习/最小二乘法/">最小二乘法</a>
</li>
            
<li >
    <a href="../../../深度学习/矩阵分解/">矩阵分解</a>
</li>
            
<li >
    <a href="../../../深度学习/矩阵求导/">矩阵求导</a>
</li>
    </ul>
  </li>
                            
  <li class="dropdown-submenu">
    <a href="#">转载</a>
    <ul class="dropdown-menu">
            
  <li class="dropdown-submenu">
    <a href="#">cs231n-ch</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../ch-assignment2_google_cloud/">Google Cloud Tutorial Part 2 (with GPUs)</a>
</li>
            
<li >
    <a href="../ch-aws-tutorial/">aws-tutorial</a>
</li>
            
<li >
    <a href="../ch-classification/">classification</a>
</li>
            
<li >
    <a href="../ch-convnet-tips/">convnet-tips</a>
</li>
            
<li >
    <a href="../ch-convolutional-networks/">convolutional-networks</a>
</li>
            
<li >
    <a href="../ch-google_cloud_tutorial/">Google Cloud Tutorial gce-tutorial</a>
</li>
            
<li >
    <a href="../ch-ipython-tutorial/">IPython Tutorial ipython-tutorial</a>
</li>
            
<li >
    <a href="../ch-linear-classify/">线性分类</a>
</li>
            
<li >
    <a href="../ch-neural-networks-1/">neural-networks-1</a>
</li>
            
<li class="active">
    <a href="./">neural-networks-2</a>
</li>
            
<li >
    <a href="../ch-neural-networks-3/">Ch neural networks 3</a>
</li>
            
<li >
    <a href="../ch-neural-networks-case-study/">Ch neural networks case study</a>
</li>
            
<li >
    <a href="../ch-optimization-1/">Ch optimization 1</a>
</li>
            
<li >
    <a href="../ch-optimization-2/">Ch optimization 2</a>
</li>
            
<li >
    <a href="../ch-overview/">Ch overview</a>
</li>
            
<li >
    <a href="../ch-poster/">Ch poster</a>
</li>
            
<li >
    <a href="../ch-python-numpy-tutorial/">Ch python numpy tutorial</a>
</li>
            
<li >
    <a href="../ch-Readme/">ch Readme</a>
</li>
            
<li >
    <a href="../ch-transfer-learning/">Ch transfer learning</a>
</li>
            
<li >
    <a href="../ch-understanding-cnn/">Ch understanding cnn</a>
</li>
            
<li >
    <a href="../terminal-tutorial/">Terminal tutorial</a>
</li>
    </ul>
  </li>
            
  <li class="dropdown-submenu">
    <a href="#">cs231n-en</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../../cs231n-en/en-assignment2_google_cloud/">En assignment2 google cloud</a>
</li>
            
<li >
    <a href="../../cs231n-en/en-aws-tutorial/">En aws tutorial</a>
</li>
            
<li >
    <a href="../../cs231n-en/en-classification/">En classification</a>
</li>
            
<li >
    <a href="../../cs231n-en/en-convnet-tips/">En convnet tips</a>
</li>
            
<li >
    <a href="../../cs231n-en/en-convolutional-networks/">En convolutional networks</a>
</li>
            
<li >
    <a href="../../cs231n-en/en-google_cloud_tutorial/">En google cloud tutorial</a>
</li>
            
<li >
    <a href="../../cs231n-en/en-ipython-tutorial/">En ipython tutorial</a>
</li>
            
<li >
    <a href="../../cs231n-en/en-linear-classify/">En linear classify</a>
</li>
            
<li >
    <a href="../../cs231n-en/en-neural-networks-1/">En neural networks 1</a>
</li>
            
<li >
    <a href="../../cs231n-en/en-neural-networks-2/">En neural networks 2</a>
</li>
            
<li >
    <a href="../../cs231n-en/en-neural-networks-3/">En neural networks 3</a>
</li>
            
<li >
    <a href="../../cs231n-en/en-neural-networks-case-study/">En neural networks case study</a>
</li>
            
<li >
    <a href="../../cs231n-en/en-optimization-1/">En optimization 1</a>
</li>
            
<li >
    <a href="../../cs231n-en/en-optimization-2/">En optimization 2</a>
</li>
            
<li >
    <a href="../../cs231n-en/en-overview/">En overview</a>
</li>
            
<li >
    <a href="../../cs231n-en/en-poster/">En poster</a>
</li>
            
<li >
    <a href="../../cs231n-en/en-python-numpy-tutorial/">En python numpy tutorial</a>
</li>
            
<li >
    <a href="../../cs231n-en/en-Readme/">en Readme</a>
</li>
            
<li >
    <a href="../../cs231n-en/en-terminal-tutorial/">En terminal tutorial</a>
</li>
            
<li >
    <a href="../../cs231n-en/en-transfer-learning/">En transfer learning</a>
</li>
            
<li >
    <a href="../../cs231n-en/en-understanding-cnn/">En understanding cnn</a>
</li>
    </ul>
  </li>
            
  <li class="dropdown-submenu">
    <a href="#">example</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../../example/a-web-crawer-with-a-asyncio-coroutines-1/">A web crawer with a asyncio coroutines 1</a>
</li>
            
<li >
    <a href="../../example/a-web-crawer-with-a-asyncio-coroutines-2/">A web crawer with a asyncio coroutines 2</a>
</li>
            
<li >
    <a href="../../example/bias-variance/">Bias variance</a>
</li>
            
<li >
    <a href="../../example/bitcoin-explained-1/">Bitcoin explained 1</a>
</li>
            
<li >
    <a href="../../example/dive-into-gradient-decent/">Dive into gradient decent</a>
</li>
            
<li >
    <a href="../../example/ethereum-ultimate-guide/">Ethereum ultimate guide</a>
</li>
            
<li >
    <a href="../../example/fork-exec-source/">Fork exec source</a>
</li>
            
<li >
    <a href="../../example/latex语法/">Latex语法</a>
</li>
            
<li >
    <a href="../../example/latex语法1/">Latex语法1</a>
</li>
            
<li >
    <a href="../../example/nosql-in-python/">Nosql in python</a>
</li>
            
<li >
    <a href="../../example/perceptron/">Perceptron</a>
</li>
            
<li >
    <a href="../../example/quick-latex/">Quick latex</a>
</li>
            
<li >
    <a href="../../example/tendermint/">Tendermint</a>
</li>
    </ul>
  </li>
            
  <li class="dropdown-submenu">
    <a href="#">example2</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../../example2/arrays-similar/">Arrays similar</a>
</li>
            
<li >
    <a href="../../example2/baidu-ife-1/">Baidu ife 1</a>
</li>
            
<li >
    <a href="../../example2/create-my-blog-with-jekyll/">Create my blog with jekyll</a>
</li>
            
<li >
    <a href="../../example2/front-end-tools/">Front end tools</a>
</li>
            
<li >
    <a href="../../example2/git-clone-not-master-branch/">Git clone not master branch</a>
</li>
            
<li >
    <a href="../../example2/History-API/">History API</a>
</li>
            
<li >
    <a href="../../example2/how-to-use-babel/">How to use babel</a>
</li>
            
<li >
    <a href="../../example2/how-to-write-a-count-down/">How to write a count down</a>
</li>
            
<li >
    <a href="../../example2/JavaScript-closure/">JavaScript closure</a>
</li>
            
<li >
    <a href="../../example2/JavaScript-function/">JavaScript function</a>
</li>
            
<li >
    <a href="../../example2/JavaScript-good-parts-note1/">JavaScript good parts note1</a>
</li>
            
<li >
    <a href="../../example2/JavaScript-good-parts-note2/">JavaScript good parts note2</a>
</li>
            
<li >
    <a href="../../example2/JavaScript-good-parts-note3/">JavaScript good parts note3</a>
</li>
            
<li >
    <a href="../../example2/JavaScript-Net/">JavaScript Net</a>
</li>
            
<li >
    <a href="../../example2/JavaScript-Object-Oriented/">JavaScript Object Oriented</a>
</li>
            
<li >
    <a href="../../example2/JavaScript-this/">JavaScript this</a>
</li>
            
<li >
    <a href="../../example2/jekyll-theme-version-2.0/">Jekyll theme version 2.0</a>
</li>
            
<li >
    <a href="../../example2/js-create-file-and-download/">Js create file and download</a>
</li>
            
<li >
    <a href="../../example2/low-IE-click-empty-block-bug/">low IE click empty block bug</a>
</li>
            
<li >
    <a href="../../example2/regular-expression-group/">Regular expression group</a>
</li>
            
<li >
    <a href="../../example2/scope/">Scope</a>
</li>
            
<li >
    <a href="../../example2/shuffle-algorithm/">Shuffle algorithm</a>
</li>
            
<li >
    <a href="../../example2/sublimeLinter/">sublimeLinter</a>
</li>
            
<li >
    <a href="../../example2/Syncing-a-fork/">Syncing a fork</a>
</li>
            
<li >
    <a href="../../example2/teach-girlfriend-html-css/">Teach girlfriend html css</a>
</li>
            
<li >
    <a href="../../example2/web-app/">Web app</a>
</li>
            
<li >
    <a href="../../example2/weinre/">Weinre</a>
</li>
    </ul>
  </li>
    </ul>
  </li>
                        </ul>
                    </li>
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">工具 <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                            
<li >
    <a href="../../../../工具/About/">About</a>
</li>
                            
<li >
    <a href="../../../../工具/Cheatsheet/">Cheatsheet</a>
</li>
                            
<li >
    <a href="../../../../工具/">Home</a>
</li>
                            
<li >
    <a href="../../../../工具/shell显示时间/">Shell显示时间</a>
</li>
                            
  <li class="dropdown-submenu">
    <a href="#">常用工具</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../../../../工具/常用工具/10分钟上手Latex/">10分钟上手Latex</a>
</li>
            
<li >
    <a href="../../../../工具/常用工具/10分钟上手Pandas/">10分钟上手Pandas</a>
</li>
            
<li >
    <a href="../../../../工具/常用工具/10分钟上手Python/">10分钟上手Python</a>
</li>
    </ul>
  </li>
                        </ul>
                    </li>
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">文章 <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                            
<li >
    <a href="../../../../文章/">Home</a>
</li>
                        </ul>
                    </li>
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">日常 <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                            
<li >
    <a href="../../../../日常/">Home</a>
</li>
                            
  <li class="dropdown-submenu">
    <a href="#">test</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../../../../日常/test/testtest/">Testtest</a>
</li>
    </ul>
  </li>
                        </ul>
                    </li>
                </ul>

            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                        <i class="fa fa-search"></i> Search
                    </a>
                </li>
                    <li >
                        <a rel="next" href="../ch-neural-networks-1/">
                            <i class="fa fa-arrow-left"></i> Previous
                        </a>
                    </li>
                    <li >
                        <a rel="prev" href="../ch-neural-networks-3/">
                            Next <i class="fa fa-arrow-right"></i>
                        </a>
                    </li>
                    <li>
                        <a href="https://github.com/1007530194/Diary">1007530194/Diary</a>
                    </li>
            </ul>
        </div>
    </div>
</div>

        <div class="container">
                <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
        <li class="main active"><a href="#setting_up_the_data_and_the_model">Setting up the data and the model</a></li>
            <li><a href="#data_preprocessing">Data Preprocessing</a></li>
            <li><a href="#weight_initialization">Weight Initialization</a></li>
            <li><a href="#regularization">Regularization</a></li>
            <li><a href="#loss_functions">Loss functions</a></li>
        <li class="main "><a href="#summary">Summary</a></li>
    </ul>
</div></div>
                <div class="col-md-9" role="main">

<p>Table of Contents:</p>
<ul>
<li><a href="#intro">Setting up the data and the model</a></li>
<li><a href="#datapre">Data Preprocessing</a></li>
<li><a href="#init">Weight Initialization</a></li>
<li><a href="#batchnorm">Batch Normalization</a></li>
<li><a href="#reg">Regularization</a> (L2/L1/Maxnorm/Dropout)</li>
<li><a href="#losses">Loss functions</a></li>
<li><a href="#summary">Summary</a></li>
</ul>
<p><a name='intro'></a></p>
<h2 id="setting_up_the_data_and_the_model">Setting up the data and the model<a class="headerlink" href="#setting_up_the_data_and_the_model" title="Permanent link">&para;</a></h2>
<p>In the previous section we introduced a model of a Neuron, which computes a dot product following a non-linearity, and Neural Networks that arrange neurons into layers. Together, these choices define the new form of the <strong>score function</strong>, which we have extended from the simple linear mapping that we have seen in the Linear Classification section. In particular, a Neural Network performs a sequence of linear mappings with interwoven non-linearities. In this section we will discuss additional design choices regarding data preprocessing, weight initialization, and loss functions.</p>
<p><a name='datapre'></a></p>
<h3 id="data_preprocessing">Data Preprocessing<a class="headerlink" href="#data_preprocessing" title="Permanent link">&para;</a></h3>
<p>There are three common forms of data preprocessing a data matrix <code>X</code>, where we will assume that <code>X</code> is of size <code>[N x D]</code> (<code>N</code> is the number of data, <code>D</code> is their dimensionality).</p>
<p><strong>Mean subtraction</strong>  is the most common form of preprocessing. It involves subtracting the mean across every individual <em>feature</em> in the data, and has the geometric interpretation of centering the cloud of data around the origin along every dimension. In numpy, this operation would be implemented as: <code>X -= np.mean(X, axis = 0)</code>. With images specifically, for convenience it can be common to subtract a single value from all pixels (e.g. <code>X -= np.mean(X)</code>), or to do so separately across the three color channels.</p>
<p><strong>Normalization</strong> refers to normalizing the data dimensions so that they are of approximately the same scale. There are two common ways of achieving this normalization. One is to divide each dimension by its standard deviation, once it has been zero-centered: (<code>X /= np.std(X, axis = 0)</code>). Another form of this preprocessing normalizes each dimension so that the min and max along the dimension is -1 and 1 respectively. It only makes sense to apply this preprocessing if you have a reason to believe that different input features have different scales (or units), but they should be of approximately equal importance to the learning algorithm.
In case of images, the relative scales of pixels are already approximately equal (and in range from 0 to 255), so it is not strictly necessary to perform this additional preprocessing step.</p>
<div class="fig figcenter fighighlight">
  <img src="/Dairy/assets/images/cs231n/nn2/prepro1.jpeg">
  <div class="figcaption">Common data preprocessing pipeline. <b>Left</b>: Original toy, 2-dimensional input data. <b>Middle</b>: The data is zero-centered by subtracting the mean in each dimension. The data cloud is now centered around the origin. <b>Right</b>: Each dimension is additionally scaled by its standard deviation. The red lines indicate the extent of the data - they are of unequal length in the middle, but of equal length on the right.</div>
</div>

<p><strong>PCA and Whitening</strong> is another form of preprocessing. In this process, the data is first centered as described above. Then, we can compute the covariance matrix that tells us about the correlation structure in the data:</p>
<div class="codehilite"><pre><span></span><span class="c1"># Assume input data matrix X of size [N x D]</span>
<span class="n">X</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="c1"># zero-center the data (important)</span>
<span class="n">cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span> <span class="o">/</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># get the data covariance matrix</span>
</pre></div>

<p>The (i,j) element of the data covariance matrix contains the <em>covariance</em> between i-th and j-th dimension of the data. In particular, the diagonal of this matrix contains the variances. Furthermore, the covariance matrix is symmetric and <a href="http://en.wikipedia.org/wiki/Positive-definite_matrix#Negative-definite.2C_semidefinite_and_indefinite_matrices">positive semi-definite</a>. We can compute the SVD factorization of the data covariance matrix:</p>
<div class="codehilite"><pre><span></span><span class="n">U</span><span class="p">,</span><span class="n">S</span><span class="p">,</span><span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">cov</span><span class="p">)</span>
</pre></div>

<p>where the columns of <code>U</code> are the eigenvectors and <code>S</code> is a 1-D array of the singular values. To decorrelate the data, we project the original (but zero-centered) data into the eigenbasis:</p>
<div class="codehilite"><pre><span></span><span class="n">Xrot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">U</span><span class="p">)</span> <span class="c1"># decorrelate the data</span>
</pre></div>

<p>Notice that the columns of <code>U</code> are a set of orthonormal vectors (norm of 1, and orthogonal to each other), so they can be regarded as basis vectors. The projection therefore corresponds to a rotation of the data in <code>X</code> so that the new axes are the eigenvectors. If we were to compute the covariance matrix of <code>Xrot</code>, we would see that it is now diagonal. A nice property of <code>np.linalg.svd</code> is that in its returned value <code>U</code>, the eigenvector columns are sorted by their eigenvalues. We can use this to reduce the dimensionality of the data by only using the top few eigenvectors, and discarding the dimensions along which the data has no variance. This is also sometimes refereed to as <a href="http://en.wikipedia.org/wiki/Principal_component_analysis">Principal Component Analysis (PCA)</a> dimensionality reduction:</p>
<div class="codehilite"><pre><span></span><span class="n">Xrot_reduced</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">U</span><span class="p">[:,:</span><span class="mi">100</span><span class="p">])</span> <span class="c1"># Xrot_reduced becomes [N x 100]</span>
</pre></div>

<p>After this operation, we would have reduced the original dataset of size [N x D] to one of size [N x 100], keeping the 100 dimensions of the data that contain the most variance. It is very often the case that you can get very good performance by training linear classifiers or neural networks on the PCA-reduced datasets, obtaining savings in both space and time.</p>
<p>The last transformation you may see in practice is <strong>whitening</strong>. The whitening operation takes the data in the eigenbasis and divides every dimension by the eigenvalue to normalize the scale. The geometric interpretation of this transformation is that if the input data is a multivariable gaussian, then the whitened data will be a gaussian with zero mean and identity covariance matrix. This step would take the form:</p>
<div class="codehilite"><pre><span></span><span class="c1"># whiten the data:</span>
<span class="c1"># divide by the eigenvalues (which are square roots of the singular values)</span>
<span class="n">Xwhite</span> <span class="o">=</span> <span class="n">Xrot</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">S</span> <span class="o">+</span> <span class="mf">1e-5</span><span class="p">)</span>
</pre></div>

<p><em>Warning: Exaggerating noise.</em> Note that we're adding 1e-5 (or a small constant) to prevent division by zero. One weakness of this transformation is that it can greatly exaggerate the noise in the data, since it stretches all dimensions (including the irrelevant dimensions of tiny variance that are mostly noise) to be of equal size in the input. This can in practice be mitigated by stronger smoothing (i.e. increasing 1e-5 to be a larger number).</p>
<div class="fig figcenter fighighlight">
  <img src="/Dairy/assets/images/cs231n/nn2/prepro2.jpeg">
  <div class="figcaption">PCA / Whitening. <b>Left</b>: Original toy, 2-dimensional input data. <b>Middle</b>: After performing PCA. The data is centered at zero and then rotated into the eigenbasis of the data covariance matrix. This decorrelates the data (the covariance matrix becomes diagonal). <b>Right</b>: Each dimension is additionally scaled by the eigenvalues, transforming the data covariance matrix into the identity matrix. Geometrically, this corresponds to stretching and squeezing the data into an isotropic gaussian blob.</div>
</div>

<p>We can also try to visualize these transformations with CIFAR-10 images. The training set of CIFAR-10 is of size 50,000 x 3072, where every image is stretched out into a 3072-dimensional row vector. We can then compute the [3072 x 3072] covariance matrix and compute its SVD decomposition (which can be relatively expensive). What do the computed eigenvectors look like visually? An image might help:</p>
<div class="fig figcenter fighighlight">
  <img src="/Dairy/assets/images/cs231n/nn2/cifar10pca.jpeg">
  <div class="figcaption"><b>Left:</b>An example set of 49 images. <b>2nd from Left:</b> The top 144 out of 3072 eigenvectors. The top eigenvectors account for most of the variance in the data, and we can see that they correspond to lower frequencies in the images.  <b>2nd from Right:</b> The 49 images reduced with PCA, using the 144 eigenvectors shown here. That is, instead of expressing every image as a 3072-dimensional vector where each element is the brightness of a particular pixel at some location and channel, every image above is only represented with a 144-dimensional vector, where each element measures how much of each eigenvector adds up to make up the image. In order to visualize what image information has been retained in the 144 numbers, we must rotate back into the "pixel" basis of 3072 numbers. Since U is a rotation, this can be achieved by multiplying by U.transpose()[:144,:], and then visualizing the resulting 3072 numbers as the image. You can see that the images are slightly blurrier, reflecting the fact that the top eigenvectors capture lower frequencies. However, most of the information is still preserved. <b>Right:</b> Visualization of the "white" representation, where the variance along every one of the 144 dimensions is squashed to equal length. Here, the whitened 144 numbers are rotated back to image pixel basis by multiplying by U.transpose()[:144,:]. The lower frequencies (which accounted for most variance) are now negligible, while the higher frequencies (which account for relatively little variance originally) become exaggerated.</div>
</div>

<p><strong>In practice.</strong> We mention PCA/Whitening in these notes for completeness, but these transformations are not used with Convolutional Networks. However, it is very important to zero-center the data, and it is common to see normalization of every pixel as well.</p>
<p><strong>Common pitfall</strong>. An important point to make about the preprocessing is that any preprocessing statistics (e.g. the data mean) must only be computed on the training data, and then applied to the validation / test data. E.g. computing the mean and subtracting it from every image across the entire dataset and then splitting the data into train/val/test splits would be a mistake. Instead, the mean must be computed only over the training data and then subtracted equally from all splits (train/val/test).</p>
<p><a name='init'></a></p>
<h3 id="weight_initialization">Weight Initialization<a class="headerlink" href="#weight_initialization" title="Permanent link">&para;</a></h3>
<p>We have seen how to construct a Neural Network architecture, and how to preprocess the data. Before we can begin to train the network we have to initialize its parameters.</p>
<p><strong>Pitfall: all zero initialization</strong>. Lets start with what we should not do. Note that we do not know what the final value of every weight should be in the trained network, but with proper data normalization it is reasonable to assume that approximately half of the weights will be positive and half of them will be negative. A reasonable-sounding idea then might be to set all the initial weights to zero, which we expect to be the "best guess" in expectation. This turns out to be a mistake, because if every neuron in the network computes the same output, then they will also all compute the same gradients during backpropagation and undergo the exact same parameter updates. In other words, there is no source of asymmetry between neurons if their weights are initialized to be the same.</p>
<p><strong>Small random numbers</strong>. Therefore, we still want the weights to be very close to zero, but as we have argued above, not identically zero. As a solution, it is common to initialize the weights of the neurons to small numbers and refer to doing so as <em>symmetry breaking</em>. The idea is that the neurons are all random and unique in the beginning, so they will compute distinct updates and integrate themselves as diverse parts of the full network. The implementation for one weight matrix might look like <code>W = 0.01* np.random.randn(D,H)</code>, where <code>randn</code> samples from a zero mean, unit standard deviation gaussian. With this formulation, every neuron's weight vector is initialized as a random vector sampled from a multi-dimensional gaussian, so the neurons point in random direction in the input space. It is also possible to use small numbers drawn from a uniform distribution, but this seems to have relatively little impact on the final performance in practice.</p>
<p><em>Warning</em>: It's not necessarily the case that smaller numbers will work strictly better. For example, a Neural Network layer that has very small weights will during backpropagation compute very small gradients on its data (since this gradient is proportional to the value of the weights). This could greatly diminish the "gradient signal" flowing backward through a network, and could become a concern for deep networks.</p>
<p><strong>Calibrating the variances with 1/sqrt(n)</strong>. One problem with the above suggestion is that the distribution of the outputs from a randomly initialized neuron has a variance that grows with the number of inputs. It turns out that we can normalize the variance of each neuron's output to 1 by scaling its weight vector by the square root of its <em>fan-in</em> (i.e. its number of inputs). That is, the recommended heuristic is to initialize each neuron's weight vector as: <code>w = np.random.randn(n) / sqrt(n)</code>, where <code>n</code> is the number of its inputs. This ensures that all neurons in the network initially have approximately the same output distribution and empirically improves the rate of convergence.</p>
<p>The sketch of the derivation is as follows: Consider the inner product <span><span class="MathJax_Preview">s = \sum_i^n w_i x_i</span><script type="math/tex">s = \sum_i^n w_i x_i</script></span> between the weights <span><span class="MathJax_Preview">w</span><script type="math/tex">w</script></span> and input <span><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span>, which gives the raw activation of a neuron before the non-linearity. We can examine the variance of <span><span class="MathJax_Preview">s</span><script type="math/tex">s</script></span>:</p>
<div>
<div class="MathJax_Preview">
\begin{align}
\text{Var}(s) &amp;= \text{Var}(\sum_i^n w_ix_i) \\\\
&amp;= \sum_i^n \text{Var}(w_ix_i) \\\\
&amp;= \sum_i^n [E(w_i)]^2\text{Var}(x_i) + E[(x_i)]^2\text{Var}(w_i) + \text{Var}(x_i)\text{Var}(w_i) \\\\
&amp;= \sum_i^n \text{Var}(x_i)\text{Var}(w_i) \\\\
&amp;= \left( n \text{Var}(w) \right) \text{Var}(x)
\end{align}
</div>
<script type="math/tex; mode=display">
\begin{align}
\text{Var}(s) &= \text{Var}(\sum_i^n w_ix_i) \\\\
&= \sum_i^n \text{Var}(w_ix_i) \\\\
&= \sum_i^n [E(w_i)]^2\text{Var}(x_i) + E[(x_i)]^2\text{Var}(w_i) + \text{Var}(x_i)\text{Var}(w_i) \\\\
&= \sum_i^n \text{Var}(x_i)\text{Var}(w_i) \\\\
&= \left( n \text{Var}(w) \right) \text{Var}(x)
\end{align}
</script>
</div>
<p>where in the first 2 steps we have used <a href="http://en.wikipedia.org/wiki/Variance">properties of variance</a>. In third step we assumed zero mean inputs and weights, so <span><span class="MathJax_Preview">E[x_i] = E[w_i] = 0</span><script type="math/tex">E[x_i] = E[w_i] = 0</script></span>. Note that this is not generally the case: For example ReLU units will have a positive mean. In the last step we assumed that all <span><span class="MathJax_Preview">w_i, x_i</span><script type="math/tex">w_i, x_i</script></span> are identically distributed. From this derivation we can see that if we want <span><span class="MathJax_Preview">s</span><script type="math/tex">s</script></span> to have the same variance as all of its inputs <span><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span>, then during initialization we should make sure that the variance of every weight <span><span class="MathJax_Preview">w</span><script type="math/tex">w</script></span> is <span><span class="MathJax_Preview">1/n</span><script type="math/tex">1/n</script></span>. And since <span><span class="MathJax_Preview">\text{Var}(aX) = a^2\text{Var}(X)</span><script type="math/tex">\text{Var}(aX) = a^2\text{Var}(X)</script></span> for a random variable <span><span class="MathJax_Preview">X</span><script type="math/tex">X</script></span> and a scalar <span><span class="MathJax_Preview">a</span><script type="math/tex">a</script></span>, this implies that we should draw from unit gaussian and then scale it by <span><span class="MathJax_Preview">a = \sqrt{1/n}</span><script type="math/tex">a = \sqrt{1/n}</script></span>, to make its variance <span><span class="MathJax_Preview">1/n</span><script type="math/tex">1/n</script></span>. This gives the initialization <code>w = np.random.randn(n) / sqrt(n)</code>.</p>
<p>A similar analysis is carried out in <a href="http://jmlr.org/proceedings/papers/v9/glorot10a/glorot10a.pdf">Understanding the difficulty of training deep feedforward neural networks</a> by Glorot et al. In this paper, the authors end up recommending an initialization of the form $ \text{Var}(w) = 2/(n_{in} + n_{out}) $ where <span><span class="MathJax_Preview">n_{in}, n_{out}</span><script type="math/tex">n_{in}, n_{out}</script></span> are the number of units in the previous layer and the next layer. This is based on a compromise and an equivalent analysis of the backpropagated gradients. A more recent paper on this topic, <a href="http://arxiv-web3.library.cornell.edu/abs/1502.01852">Delving Deep into Rectifiers: Surpassing Human-Level Performance on ImageNet Classification</a> by He et al., derives an initialization specifically for ReLU neurons, reaching the conclusion that the variance of neurons in the network should be <span><span class="MathJax_Preview">2.0/n</span><script type="math/tex">2.0/n</script></span>. This gives the initialization <code>w = np.random.randn(n) * sqrt(2.0/n)</code>, and is the current recommendation for use in practice in the specific case of neural networks with ReLU neurons.</p>
<p><strong>Sparse initialization</strong>. Another way to address the uncalibrated variances problem is to set all weight matrices to zero, but to break symmetry every neuron is randomly connected (with weights sampled from a small gaussian as above) to a fixed number of neurons below it. A typical number of neurons to connect to may be as small as 10.</p>
<p><strong>Initializing the biases</strong>. It is possible and common to initialize the biases to be zero, since the asymmetry breaking is provided by the small random numbers in the weights. For ReLU non-linearities, some people like to use small constant value such as 0.01 for all biases because this ensures that all ReLU units fire in the beginning and therefore obtain and propagate some gradient. However, it is not clear if this provides a consistent improvement (in fact some results seem to indicate that this performs worse) and it is more common to simply use 0 bias initialization.</p>
<p><strong>In practice</strong>, the current recommendation is to use ReLU units and use the <code>w = np.random.randn(n) * sqrt(2.0/n)</code>, as discussed in <a href="http://arxiv-web3.library.cornell.edu/abs/1502.01852">He et al.</a>. </p>
<p><a name='batchnorm'></a></p>
<p><strong>Batch Normalization</strong>. A recently developed technique by Ioffe and Szegedy called <a href="http://arxiv.org/abs/1502.03167">Batch Normalization</a> alleviates a lot of headaches with properly initializing neural networks by explicitly forcing the activations throughout a network to take on a unit gaussian distribution at the beginning of the training. The core observation is that this is possible because normalization is a simple differentiable operation. In the implementation, applying this technique usually amounts to insert the BatchNorm layer immediately after fully connected layers (or convolutional layers, as we'll soon see), and before non-linearities. We do not expand on this technique here because it is well described in the linked paper, but note that it has become a very common practice to use Batch Normalization in neural networks. In practice networks that use Batch Normalization are significantly more robust to bad initialization. Additionally, batch normalization can be interpreted as doing preprocessing at every layer of the network, but integrated into the network itself in a differentiable manner. Neat!</p>
<p><a name='reg'></a></p>
<h3 id="regularization">Regularization<a class="headerlink" href="#regularization" title="Permanent link">&para;</a></h3>
<p>There are several ways of controlling the capacity of Neural Networks to prevent overfitting:</p>
<p><strong>L2 regularization</strong> is perhaps the most common form of regularization. It can be implemented by penalizing the squared magnitude of all parameters directly in the objective. That is, for every weight <span><span class="MathJax_Preview">w</span><script type="math/tex">w</script></span> in the network, we add the term <span><span class="MathJax_Preview">\frac{1}{2} \lambda w^2</span><script type="math/tex">\frac{1}{2} \lambda w^2</script></span> to the objective, where <span><span class="MathJax_Preview">\lambda</span><script type="math/tex">\lambda</script></span> is the regularization strength. It is common to see the factor of <span><span class="MathJax_Preview">\frac{1}{2}</span><script type="math/tex">\frac{1}{2}</script></span> in front because then the gradient of this term with respect to the parameter <span><span class="MathJax_Preview">w</span><script type="math/tex">w</script></span> is simply <span><span class="MathJax_Preview">\lambda w</span><script type="math/tex">\lambda w</script></span> instead of <span><span class="MathJax_Preview">2 \lambda w</span><script type="math/tex">2 \lambda w</script></span>. The L2 regularization has the intuitive interpretation of heavily penalizing peaky weight vectors and preferring diffuse weight vectors. As we discussed in the Linear Classification section, due to multiplicative interactions between weights and inputs this has the appealing property of encouraging the network to use all of its inputs a little rather that some of its inputs a lot. Lastly, notice that during gradient descent parameter update, using the L2 regularization ultimately means that every weight is decayed linearly: <code>W += -lambda * W</code> towards zero.</p>
<p><strong>L1 regularization</strong> is another relatively common form of regularization, where for each weight <span><span class="MathJax_Preview">w</span><script type="math/tex">w</script></span> we add the term <span><span class="MathJax_Preview">\lambda  \mid w \mid</span><script type="math/tex">\lambda  \mid w \mid</script></span> to the objective. It is possible to combine the L1 regularization with the L2 regularization: <span><span class="MathJax_Preview">\lambda_1 \mid w \mid + \lambda_2 w^2</span><script type="math/tex">\lambda_1 \mid w \mid + \lambda_2 w^2</script></span> (this is called <a href="http://web.stanford.edu/~hastie/Papers/B67.2%20%282005%29%20301-320%20Zou%20&amp;%20Hastie.pdf">Elastic net regularization</a>). The L1 regularization has the intriguing property that it leads the weight vectors to become sparse during optimization (i.e. very close to exactly zero). In other words, neurons with L1 regularization end up using only a sparse subset of their most important inputs and become nearly invariant to the "noisy" inputs. In comparison, final weight vectors from L2 regularization are usually diffuse, small numbers. In practice, if you are not concerned with explicit feature selection, L2 regularization can be expected to give superior performance over L1.</p>
<p><strong>Max norm constraints</strong>. Another form of regularization is to enforce an absolute upper bound on the magnitude of the weight vector for every neuron and use projected gradient descent to enforce the constraint. In practice, this corresponds to performing the parameter update as normal, and then enforcing the constraint by clamping the weight vector <span><span class="MathJax_Preview">\vec{w}</span><script type="math/tex">\vec{w}</script></span> of every neuron to satisfy <span><span class="MathJax_Preview">\Vert \vec{w} \Vert_2 &lt; c</span><script type="math/tex">\Vert \vec{w} \Vert_2 < c</script></span>. Typical values of <span><span class="MathJax_Preview">c</span><script type="math/tex">c</script></span> are on orders of 3 or 4. Some people report improvements when using this form of regularization. One of its appealing properties is that network cannot "explode" even when the learning rates are set too high because the updates are always bounded.</p>
<p><strong>Dropout</strong> is an extremely effective, simple and recently introduced regularization technique by Srivastava et al. in <a href="http://www.cs.toronto.edu/~rsalakhu/papers/srivastava14a.pdf">Dropout: A Simple Way to Prevent Neural Networks from Overfitting</a> (pdf) that complements the other methods (L1, L2, maxnorm). While training, dropout is implemented by only keeping a neuron active with some probability <span><span class="MathJax_Preview">p</span><script type="math/tex">p</script></span> (a hyperparameter), or setting it to zero otherwise.</p>
<div class="fig figcenter fighighlight">
  <img src="/Dairy/assets/images/cs231n/nn2/dropout.jpeg" width="70%">
  <div class="figcaption">Figure taken from the <a href="http://www.cs.toronto.edu/~rsalakhu/papers/srivastava14a.pdf">Dropout paper</a> that illustrates the idea. During training, Dropout can be interpreted as sampling a Neural Network within the full Neural Network, and only updating the parameters of the sampled network based on the input data. (However, the exponential number of possible sampled networks are not independent because they share the parameters.) During testing there is no dropout applied, with the interpretation of evaluating an averaged prediction across the exponentially-sized ensemble of all sub-networks (more about ensembles in the next section).</div>
</div>

<p>Vanilla dropout in an example 3-layer Neural Network would be implemented as follows:</p>
<div class="codehilite"><pre><span></span><span class="sd">&quot;&quot;&quot; Vanilla Dropout: Not recommended implementation (see notes below) &quot;&quot;&quot;</span>

<span class="n">p</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="c1"># probability of keeping a unit active. higher = less dropout</span>

<span class="k">def</span> <span class="nf">train_step</span><span class="p">(</span><span class="n">X</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot; X contains the data &quot;&quot;&quot;</span>

  <span class="c1"># forward pass for example 3-layer neural network</span>
  <span class="n">H1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W1</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span> <span class="o">+</span> <span class="n">b1</span><span class="p">)</span>
  <span class="n">U1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="o">*</span><span class="n">H1</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">p</span> <span class="c1"># first dropout mask</span>
  <span class="n">H1</span> <span class="o">*=</span> <span class="n">U1</span> <span class="c1"># drop!</span>
  <span class="n">H2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W2</span><span class="p">,</span> <span class="n">H1</span><span class="p">)</span> <span class="o">+</span> <span class="n">b2</span><span class="p">)</span>
  <span class="n">U2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="o">*</span><span class="n">H2</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">p</span> <span class="c1"># second dropout mask</span>
  <span class="n">H2</span> <span class="o">*=</span> <span class="n">U2</span> <span class="c1"># drop!</span>
  <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W3</span><span class="p">,</span> <span class="n">H2</span><span class="p">)</span> <span class="o">+</span> <span class="n">b3</span>

  <span class="c1"># backward pass: compute gradients... (not shown)</span>
  <span class="c1"># perform parameter update... (not shown)</span>

<span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="n">X</span><span class="p">):</span>
  <span class="c1"># ensembled forward pass</span>
  <span class="n">H1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W1</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span> <span class="o">+</span> <span class="n">b1</span><span class="p">)</span> <span class="o">*</span> <span class="n">p</span> <span class="c1"># NOTE: scale the activations</span>
  <span class="n">H2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W2</span><span class="p">,</span> <span class="n">H1</span><span class="p">)</span> <span class="o">+</span> <span class="n">b2</span><span class="p">)</span> <span class="o">*</span> <span class="n">p</span> <span class="c1"># NOTE: scale the activations</span>
  <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W3</span><span class="p">,</span> <span class="n">H2</span><span class="p">)</span> <span class="o">+</span> <span class="n">b3</span>
</pre></div>

<p>In the code above, inside the <code>train_step</code> function we have performed dropout twice: on the first hidden layer and on the second hidden layer. It is also possible to perform dropout right on the input layer, in which case we would also create a binary mask for the input <code>X</code>. The backward pass remains unchanged, but of course has to take into account the generated masks <code>U1,U2</code>. </p>
<p>Crucially, note that in the <code>predict</code> function we are not dropping anymore, but we are performing a scaling of both hidden layer outputs by <span><span class="MathJax_Preview">p</span><script type="math/tex">p</script></span>. This is important because at test time all neurons see all their inputs, so we want the outputs of neurons at test time to be identical to their expected outputs at training time. For example, in case of <span><span class="MathJax_Preview">p = 0.5</span><script type="math/tex">p = 0.5</script></span>, the neurons must halve their outputs at test time to have the same output as they had during training time (in expectation). To see this, consider an output of a neuron <span><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span> (before dropout). With dropout, the expected output from this neuron will become <span><span class="MathJax_Preview">px + (1-p)0</span><script type="math/tex">px + (1-p)0</script></span>, because the neuron's output will be set to zero with probability <span><span class="MathJax_Preview">1-p</span><script type="math/tex">1-p</script></span>. At test time, when we keep the neuron always active, we must adjust <span><span class="MathJax_Preview">x \rightarrow px</span><script type="math/tex">x \rightarrow px</script></span> to keep the same expected output. It can also be shown that performing this attenuation at test time can be related to the process of iterating over all the possible binary masks (and therefore all the exponentially many sub-networks) and computing their ensemble prediction.</p>
<p>The undesirable property of the scheme presented above is that we must scale the activations by <span><span class="MathJax_Preview">p</span><script type="math/tex">p</script></span> at test time. Since test-time performance is so critical, it is always preferable to use <strong>inverted dropout</strong>, which performs the scaling at train time, leaving the forward pass at test time untouched. Additionally, this has the appealing property that the prediction code can remain untouched when you decide to tweak where you apply dropout, or if at all. Inverted dropout looks as follows:</p>
<div class="codehilite"><pre><span></span><span class="sd">&quot;&quot;&quot; </span>
<span class="sd">Inverted Dropout: Recommended implementation example.</span>
<span class="sd">We drop and scale at train time and don&#39;t do anything at test time.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">p</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="c1"># probability of keeping a unit active. higher = less dropout</span>

<span class="k">def</span> <span class="nf">train_step</span><span class="p">(</span><span class="n">X</span><span class="p">):</span>
  <span class="c1"># forward pass for example 3-layer neural network</span>
  <span class="n">H1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W1</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span> <span class="o">+</span> <span class="n">b1</span><span class="p">)</span>
  <span class="n">U1</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="o">*</span><span class="n">H1</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">p</span><span class="p">)</span> <span class="o">/</span> <span class="n">p</span> <span class="c1"># first dropout mask. Notice /p!</span>
  <span class="n">H1</span> <span class="o">*=</span> <span class="n">U1</span> <span class="c1"># drop!</span>
  <span class="n">H2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W2</span><span class="p">,</span> <span class="n">H1</span><span class="p">)</span> <span class="o">+</span> <span class="n">b2</span><span class="p">)</span>
  <span class="n">U2</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="o">*</span><span class="n">H2</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">p</span><span class="p">)</span> <span class="o">/</span> <span class="n">p</span> <span class="c1"># second dropout mask. Notice /p!</span>
  <span class="n">H2</span> <span class="o">*=</span> <span class="n">U2</span> <span class="c1"># drop!</span>
  <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W3</span><span class="p">,</span> <span class="n">H2</span><span class="p">)</span> <span class="o">+</span> <span class="n">b3</span>

  <span class="c1"># backward pass: compute gradients... (not shown)</span>
  <span class="c1"># perform parameter update... (not shown)</span>

<span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="n">X</span><span class="p">):</span>
  <span class="c1"># ensembled forward pass</span>
  <span class="n">H1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W1</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span> <span class="o">+</span> <span class="n">b1</span><span class="p">)</span> <span class="c1"># no scaling necessary</span>
  <span class="n">H2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W2</span><span class="p">,</span> <span class="n">H1</span><span class="p">)</span> <span class="o">+</span> <span class="n">b2</span><span class="p">)</span>
  <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W3</span><span class="p">,</span> <span class="n">H2</span><span class="p">)</span> <span class="o">+</span> <span class="n">b3</span>
</pre></div>

<p>There has a been a large amount of research after the first introduction of dropout that tries to understand the source of its power in practice, and its relation to the other regularization techniques. Recommended further reading for an interested reader includes:</p>
<ul>
<li><a href="http://www.cs.toronto.edu/~rsalakhu/papers/srivastava14a.pdf">Dropout paper</a> by Srivastava et al. 2014.</li>
<li><a href="http://papers.nips.cc/paper/4882-dropout-training-as-adaptive-regularization.pdf">Dropout Training as Adaptive Regularization</a>: "we show that the dropout regularizer is first-order equivalent to an L2 regularizer applied after scaling the features by an estimate of the inverse diagonal Fisher information matrix".</li>
</ul>
<p><strong>Theme of noise in forward pass</strong>. Dropout falls into a more general category of methods that introduce stochastic behavior in the forward pass of the network. During testing, the noise is marginalized over <em>analytically</em> (as is the case with dropout when multiplying by <span><span class="MathJax_Preview">p</span><script type="math/tex">p</script></span>), or <em>numerically</em> (e.g. via sampling, by performing several forward passes with different random decisions and then averaging over them). An example of other research in this direction includes <a href="http://cs.nyu.edu/~wanli/dropc/">DropConnect</a>, where a random set of weights is instead set to zero during forward pass. As foreshadowing, Convolutional Neural Networks also take advantage of this theme with methods such as stochastic pooling, fractional pooling, and data augmentation. We will go into details of these methods later.</p>
<p><strong>Bias regularization</strong>. As we already mentioned in the Linear Classification section, it is not common to regularize the bias parameters because they do not interact with the data through multiplicative interactions, and therefore do not have the interpretation of controlling the influence of a data dimension on the final objective. However, in practical applications (and with proper data preprocessing) regularizing the bias rarely leads to significantly worse performance. This is likely because there are very few bias terms compared to all the weights, so the classifier can "afford to" use the biases if it needs them to obtain a better data loss.</p>
<p><strong>Per-layer regularization</strong>. It is not very common to regularize different layers to different amounts (except perhaps the output layer). Relatively few results regarding this idea have been published in the literature.</p>
<p><strong>In practice</strong>: It is most common to use a single, global L2 regularization strength that is cross-validated. It is also common to combine this with dropout applied after all layers. The value of <span><span class="MathJax_Preview">p = 0.5</span><script type="math/tex">p = 0.5</script></span> is a reasonable default, but this can be tuned on validation data.</p>
<p><a name='losses'></a></p>
<h3 id="loss_functions">Loss functions<a class="headerlink" href="#loss_functions" title="Permanent link">&para;</a></h3>
<p>We have discussed the regularization loss part of the objective, which can be seen as penalizing some measure of complexity of the model. The second part of an objective is the <em>data loss</em>, which in a supervised learning problem measures the compatibility between a prediction (e.g. the class scores in classification) and the ground truth label. The data loss takes the form of an average over the data losses for every individual example. That is, <span><span class="MathJax_Preview">L = \frac{1}{N} \sum_i L_i</span><script type="math/tex">L = \frac{1}{N} \sum_i L_i</script></span> where <span><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span> is the number of training data. Lets abbreviate <span><span class="MathJax_Preview">f = f(x_i; W)</span><script type="math/tex">f = f(x_i; W)</script></span> to be the activations of the output layer in a Neural Network. There are several types of problems you might want to solve in practice:</p>
<p><strong>Classification</strong> is the case that we have so far discussed at length. Here, we assume a dataset of examples and a single correct label (out of a fixed set) for each example. One of two most commonly seen cost functions in this setting is the SVM (e.g. the Weston Watkins formulation):</p>
<div>
<div class="MathJax_Preview">
L_i = \sum_{j\neq y_i} \max(0, f_j - f_{y_i} + 1)
</div>
<script type="math/tex; mode=display">
L_i = \sum_{j\neq y_i} \max(0, f_j - f_{y_i} + 1)
</script>
</div>
<p>As we briefly alluded to, some people report better performance with the squared hinge loss (i.e. instead using <span><span class="MathJax_Preview">\max(0, f_j - f_{y_i} + 1)^2</span><script type="math/tex">\max(0, f_j - f_{y_i} + 1)^2</script></span>). The second common choice is the Softmax classifier that uses the cross-entropy loss:</p>
<div>
<div class="MathJax_Preview">
L_i = -\log\left(\frac{e^{f_{y_i}}}{ \sum_j e^{f_j} }\right)
</div>
<script type="math/tex; mode=display">
L_i = -\log\left(\frac{e^{f_{y_i}}}{ \sum_j e^{f_j} }\right)
</script>
</div>
<p><strong>Problem: Large number of classes</strong>. When the set of labels is very large (e.g. words in English dictionary, or ImageNet which contains 22,000 categories), it may be helpful to use <em>Hierarchical Softmax</em> (see one explanation <a href="http://arxiv.org/pdf/1310.4546.pdf">here</a> (pdf)). The hierarchical softmax decomposes labels into a tree. Each label is then represented as a path along the tree, and a Softmax classifier is trained at every node of the tree to disambiguate between the left and right branch. The structure of the tree strongly impacts the performance and is generally problem-dependent.</p>
<p><strong>Attribute classification</strong>. Both losses above assume that there is a single correct answer <span><span class="MathJax_Preview">y_i</span><script type="math/tex">y_i</script></span>. But what if <span><span class="MathJax_Preview">y_i</span><script type="math/tex">y_i</script></span> is a binary vector where every example may or may not have a certain attribute, and where the attributes are not exclusive? For example, images on Instagram can be thought of as labeled with a certain subset of hashtags from a large set of all hashtags, and an image may contain multiple. A sensible approach in this case is to build a binary classifier for every single attribute independently. For example, a binary classifier for each category independently would take the form:</p>
<div>
<div class="MathJax_Preview">
L_i = \sum_j \max(0, 1 - y_{ij} f_j)
</div>
<script type="math/tex; mode=display">
L_i = \sum_j \max(0, 1 - y_{ij} f_j)
</script>
</div>
<p>where the sum is over all categories <span><span class="MathJax_Preview">j</span><script type="math/tex">j</script></span>, and <span><span class="MathJax_Preview">y_{ij}</span><script type="math/tex">y_{ij}</script></span> is either +1 or -1 depending on whether the i-th example is labeled with the j-th attribute, and the score vector <span><span class="MathJax_Preview">f_j</span><script type="math/tex">f_j</script></span> will be positive when the class is predicted to be present and negative otherwise. Notice that loss is accumulated if a positive example has score less than +1, or when a negative example has score greater than -1. </p>
<p>An alternative to this loss would be to train a logistic regression classifier for every attribute independently. A binary logistic regression classifier has only two classes (0,1), and calculates the probability of class 1 as:</p>
<div>
<div class="MathJax_Preview">
P(y = 1 \mid x; w, b) = \frac{1}{1 + e^{-(w^Tx +b)}} = \sigma (w^Tx + b)
</div>
<script type="math/tex; mode=display">
P(y = 1 \mid x; w, b) = \frac{1}{1 + e^{-(w^Tx +b)}} = \sigma (w^Tx + b)
</script>
</div>
<p>Since the probabilities of class 1 and 0 sum to one, the probability for class 0 is <span><span class="MathJax_Preview">P(y = 0 \mid x; w, b) = 1 - P(y = 1 \mid x; w,b)</span><script type="math/tex">P(y = 0 \mid x; w, b) = 1 - P(y = 1 \mid x; w,b)</script></span>. Hence, an example is classified as a positive example (y = 1) if <span><span class="MathJax_Preview">\sigma (w^Tx + b) &gt; 0.5</span><script type="math/tex">\sigma (w^Tx + b) > 0.5</script></span>, or equivalently if the score <span><span class="MathJax_Preview">w^Tx +b &gt; 0</span><script type="math/tex">w^Tx +b > 0</script></span>. The loss function then maximizes the log likelihood of this probability. You can convince yourself that this simplifies to:</p>
<div>
<div class="MathJax_Preview">
L_i = \sum_j y_{ij} \log(\sigma(f_j)) + (1 - y_{ij}) \log(1 - \sigma(f_j))
</div>
<script type="math/tex; mode=display">
L_i = \sum_j y_{ij} \log(\sigma(f_j)) + (1 - y_{ij}) \log(1 - \sigma(f_j))
</script>
</div>
<p>where the labels <span><span class="MathJax_Preview">y_{ij}</span><script type="math/tex">y_{ij}</script></span> are assumed to be either 1 (positive) or 0 (negative), and <span><span class="MathJax_Preview">\sigma(\cdot)</span><script type="math/tex">\sigma(\cdot)</script></span> is the sigmoid function. The expression above can look scary but the gradient on <span><span class="MathJax_Preview">f</span><script type="math/tex">f</script></span> is in fact extremely simple and intuitive: <span><span class="MathJax_Preview">\partial{L_i} / \partial{f_j} = y_{ij} - \sigma(f_j)</span><script type="math/tex">\partial{L_i} / \partial{f_j} = y_{ij} - \sigma(f_j)</script></span> (as you can double check yourself by taking the derivatives).</p>
<p><strong>Regression</strong> is the task of predicting real-valued quantities, such as the price of houses or the length of something in an image. For this task, it is common to compute the loss between the predicted quantity and the true answer and then measure the L2 squared norm, or L1 norm of the difference. The L2 norm squared would compute the loss for a single example of the form:</p>
<div>
<div class="MathJax_Preview">
L_i = \Vert f - y_i \Vert_2^2
</div>
<script type="math/tex; mode=display">
L_i = \Vert f - y_i \Vert_2^2
</script>
</div>
<p>The reason the L2 norm is squared in the objective is that the gradient becomes much simpler, without changing the optimal parameters since squaring is a monotonic operation. The L1 norm would be formulated by summing the absolute value along each dimension:</p>
<div>
<div class="MathJax_Preview">
L_i = \Vert f - y_i \Vert_1 = \sum_j \mid f_j - (y_i)_j \mid
</div>
<script type="math/tex; mode=display">
L_i = \Vert f - y_i \Vert_1 = \sum_j \mid f_j - (y_i)_j \mid
</script>
</div>
<p>where the sum <span><span class="MathJax_Preview">\sum_j</span><script type="math/tex">\sum_j</script></span> is a sum over all dimensions of the desired prediction, if there is more than one quantity being predicted. Looking at only the j-th dimension of the i-th example and denoting the difference between the true and the predicted value by <span><span class="MathJax_Preview">\delta_{ij}</span><script type="math/tex">\delta_{ij}</script></span>, the gradient for this dimension (i.e. <span><span class="MathJax_Preview">\partial{L_i} / \partial{f_j}</span><script type="math/tex">\partial{L_i} / \partial{f_j}</script></span>) is easily derived to be either <span><span class="MathJax_Preview">\delta_{ij}</span><script type="math/tex">\delta_{ij}</script></span> with the L2 norm, or <span><span class="MathJax_Preview">sign(\delta_{ij})</span><script type="math/tex">sign(\delta_{ij})</script></span>. That is, the gradient on the score will either be directly proportional to the difference in the error, or it will be fixed and only inherit the sign of the difference.</p>
<p><em>Word of caution</em>: It is important to note that the L2 loss is much harder to optimize than a more stable loss such as Softmax. Intuitively, it requires a very fragile and specific property from the network to output exactly one correct value for each input (and its augmentations). Notice that this is not the case with Softmax, where the precise value of each score is less important: It only matters that their magnitudes are appropriate. Additionally, the L2 loss is less robust because outliers can introduce huge gradients. When faced with a regression problem, first consider if it is absolutely inadequate to quantize the output into bins. For example, if you are predicting star rating for a product, it might work much better to use 5 independent classifiers for ratings of 1-5 stars instead of a regression loss. Classification has the additional benefit that it can give you a distribution over the regression outputs, not just a single output with no indication of its confidence. If you're certain that classification is not appropriate, use the L2 but be careful: For example, the L2 is more fragile and applying dropout in the network (especially in the layer right before the L2 loss) is not a great idea.</p>
<blockquote>
<p>When faced with a regression task, first consider if it is absolutely necessary. Instead, have a strong preference to discretizing your outputs to bins and perform classification over them whenever possible.</p>
</blockquote>
<p><strong>Structured prediction</strong>. The structured loss refers to a case where the labels can be arbitrary structures such as graphs, trees, or other complex objects. Usually it is also assumed that the space of structures is very large and not easily enumerable. The basic idea behind the structured SVM loss is to demand a margin between the correct structure <span><span class="MathJax_Preview">y_i</span><script type="math/tex">y_i</script></span> and the highest-scoring incorrect structure. It is not common to solve this problem as a simple unconstrained optimization problem with gradient descent. Instead, special solvers are usually devised so that the specific simplifying assumptions of the structure space can be taken advantage of. We mention the problem briefly but consider the specifics to be outside of the scope of the class.</p>
<p><a name='summary'></a></p>
<h2 id="summary">Summary<a class="headerlink" href="#summary" title="Permanent link">&para;</a></h2>
<p>In summary:</p>
<ul>
<li>The recommended preprocessing is to center the data to have mean of zero, and normalize its scale to [-1, 1] along each feature</li>
<li>Initialize the weights by drawing them from a gaussian distribution with standard deviation of <span><span class="MathJax_Preview">\sqrt{2/n}</span><script type="math/tex">\sqrt{2/n}</script></span>, where <span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span> is the number of inputs to the neuron. E.g. in numpy: <code>w = np.random.randn(n) * sqrt(2.0/n)</code>.</li>
<li>Use L2 regularization and dropout (the inverted version)</li>
<li>Use batch normalization</li>
<li>We discussed different tasks you might want to perform in practice, and the most common loss functions for each task</li>
</ul>
<p>We've now preprocessed the data and set up and initialized the model. In the next section we will look at the learning process and its dynamics.</p></div>
        </div>

        <footer class="col-md-12">
            <hr>
                <p>Copyright &copy; 2016 - 2018 Martin Donath</p>
            <p>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script>var base_url = '../../../..';</script>
        <script src="../../../../js/base.js"></script>
        <script src="../../../../javascripts/extra.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML"></script>
        <script src="../../../../search/require.js"></script>
        <script src="../../../../search/search.js"></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="Search Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                <h4 class="modal-title" id="exampleModalLabel">Search</h4>
            </div>
            <div class="modal-body">
                <p>
                    From here you can search these documents. Enter
                    your search terms below.
                </p>
                <form role="form">
                    <div class="form-group">
                        <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query">
                    </div>
                </form>
                <div id="mkdocs-search-results"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="Keyboard Shortcuts Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                <h4 class="modal-title" id="exampleModalLabel">Keyboard Shortcuts</h4>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td><kbd>&larr;</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td><kbd>&rarr;</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>


    </body>
</html>
