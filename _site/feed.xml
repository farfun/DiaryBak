<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Liu-Cheng Xu</title>
    <description>The world is indeed a stage and we are merely players.
</description>
    <link>http://localhost:4000/Diary/</link>
    <atom:link href="http://localhost:4000/Diary/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 08 Feb 2018 20:36:21 +0800</pubDate>
    <lastBuildDate>Thu, 08 Feb 2018 20:36:21 +0800</lastBuildDate>
    <generator>Jekyll v3.7.2</generator>
    
      <item>
        <title>为什么以太坊不仅仅是一个加密货币</title>
        <description>&lt;p&gt;尽管比特币（Bitcoin）和以太坊（Ethereum）是经常被一起提及的两个词，但实际上，比特币与以太坊有着很大的区别。它们唯一的共同点是，以太坊也是一个在区块链之上运行的加密资产。&lt;/p&gt;

&lt;p&gt;与比特币仅仅是一个加密货币不同，以太坊还有很多其他特性。正是这些特性，才使得以太坊成为了一个去中心化的超级电脑。&lt;/p&gt;

&lt;p&gt;在理解 &lt;a href=&quot;https://www.ethereum.org/&quot;&gt;以太坊&lt;/a&gt; 之前，我们必须要理解区块链是如何工作的。如果你已经了解了区块链，或者读过 &lt;a href=&quot;https://hackernoon.com/wtf-is-the-blockchain-1da89ba19348&quot;&gt;理解区块链终极指南&lt;/a&gt;，可以直接进入下一节。&lt;/p&gt;

&lt;h2 id=&quot;什么是区块链&quot;&gt;什么是区块链？&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;简单点说，区块链就是一个数据库&lt;/strong&gt;。它是一个不断增长的数据库，里面存储着特定类型的数据，并且有着一些独特的属性：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;一旦数据被存储到数据库中，它就永远也无法再被修改或是删除。区块链上的每一条记录都是永久存在的。&lt;/li&gt;
  &lt;li&gt;这个数据库，并不是由一个单一的个人或是组织维护，而是由成千上万的人在共同维护，其中的每个人都有着一份数据库的拷贝。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;为了理解为什么几个人能够持有一份拷贝，并且能够与其他人进行同步，让我们来假设现在网络里面有 10 个人，每个人的面前都有一个空的文件夹，并且有着一页空的纸。无论何时，网络中任何一个人做了一些事情，比如转账，他们必须要将这件事告诉网络里面的其他人。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/127313-8a9f6e9d2e0da178.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;ten individuals&quot; /&gt;&lt;/p&gt;

&lt;p&gt;每个人都会在纸上记录这件事，直到填满这张纸。这个时候，每个人都必须通过解决一个数学难题来封装这页纸。通过解决数学难题，保证了每个人手中的纸都有着同样的内容，并且无法被修改。谁第一个解出了题，谁就会得到一定数量的加密货币的奖励。更多内容可见：&lt;a href=&quot;https://hackernoon.com/wtf-is-the-blockchain-1da89ba19348&quot;&gt;the ultimate guide to understand blockchain&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;一旦封装完毕，这一页就会被加到文件夹里面，然后拿出新的一页，继续重复上述过程。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/127313-eaedc1ec1b63bb36.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;blockchain&quot; /&gt;&lt;/p&gt;

&lt;p&gt;随着时间不断增长，这些包含了重要记录（也就是交易，transaction）的页（也就是区块，block）不断地被加入到文件夹（链）里面，最终形成了数据库（区块链）。&lt;/p&gt;

&lt;h2 id=&quot;区块链存储了什么&quot;&gt;区块链存储了什么？&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;区块链可以用于存储各种类型的数据&lt;/strong&gt;，它所存储的数据，赋予了区块链价值。比特币区块链存储的是金融交易，因此，看起来像是美元或者英镑这样的货币。除了跟美元所承载的功能以外，比特币没有任何额外的功能。但是，以太坊则不同。&lt;/p&gt;

&lt;p&gt;以太坊不仅仅是一个像美元，英镑或者比特币一样的货币。以太坊的目标不仅是成为一个货币，更是成为下图中的事物：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/127313-bbeda1d6c5b0d786.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Ethereum&quot; /&gt;&lt;/p&gt;

&lt;p&gt;以太坊实际是一个巨型电脑！但是，它是一个非常慢的电脑 – 大概比今天的普通电脑慢上 100 倍，并且非常昂贵。“以太坊电脑” 有着跟 &lt;a href=&quot;http://www.businessinsider.in/The-worlds-first-smartphone-Simon-was-created-15-years-before-the-iPhone/articleshow/47665223.cms&quot;&gt;90 年代智能手机&lt;/a&gt; 类似的境遇。除了一些非常简单的事情以外，它几乎做不了任何事情。&lt;/p&gt;

&lt;p&gt;这听起来好像并不怎么吸引人，那么，为什么以太坊还有这么多人趋之若鹜呢？这是一个非常好的问题。不夸张的说，以太坊正在席卷整个世界，因为它是一个完全去中心化的电脑，分布在世界各地。理解以太坊区块链是如何工作的，就会看出它是如何承担了一个世界电脑的角色。&lt;/p&gt;

&lt;h2 id=&quot;以太坊是如何工作的&quot;&gt;以太坊是如何工作的？&lt;/h2&gt;

&lt;p&gt;与其他所有的区块链一样，以太坊需要数以千计的人在他们的个人电脑上运行一个软件来支撑整个网络。网络中的每个节点（电脑），运行一个叫做以太坊虚拟机（Ethereum Virtual Machine, EVM）的东西。可以把 EVM 想象成是一个操作系统，它能够理解并且执行用以太坊上特定的编程语言编写的软件。由 EVM 所执行的软件或者应用叫做 “智能合约（Smart Contract）”。&lt;/p&gt;

&lt;p&gt;为了在这台世界电脑上做一些事情，你需要进行付出一定的费用。但是，你并不是付美元或者英镑这样普通的货币。而是通过叫做以太（ether，ETH）的以太坊网络原生的加密货币，来支付相关费用。以太跟比特币几乎一模一样，唯一不同的是它被用于支付在以太坊上执行智能合约的费用。&lt;/p&gt;

&lt;p&gt;无论是一个人，还是一个智能合约，都被视作为以太坊上的用户（user）。一个人可以以太坊上做什么，一个智能合约就可以做什么。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/127313-533795e468784395.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;human user and smart contract&quot; /&gt;&lt;/p&gt;

&lt;p&gt;智能合约看起来就跟网络的其他任何人一样。它们都可以发送或者是接收以太，就跟其他的货币一样。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/127313-c469ec5c5cfc4d07.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;smart contract&quot; /&gt;&lt;/p&gt;

&lt;p&gt;但是智能合约又不是完全跟人类相同。跟人类用户不同的是，智能合约也可以执行一个预先定义好的计算机程序来执行各种操作，执行的操作可以根据事件进行触发。为了感受一下智能合约的威力，让我们来考虑一个例子：&lt;/p&gt;

&lt;h2 id=&quot;智能合约的威力&quot;&gt;智能合约的威力&lt;/h2&gt;

&lt;p&gt;假设你和我对明天的天气进行打赌，我打赌明天是晴天，但是你打赌是雨天。双方同意输的一方必须给赢的一方 100 美元。那么，我们如何才能够做到这一点，并且确保输的一方不会耍赖呢？我可以想到三种不同的方式：&lt;/p&gt;

&lt;h3 id=&quot;1-信任对方&quot;&gt;1. 信任对方&lt;/h3&gt;

&lt;p&gt;最简单的方式是信任对方。如果我们是老朋友了，那么信任对方是非常容易的。我知道你住哪儿，你也知道关于我的各种糗事。但是如果我们是完全不认识的陌生人，事情就会变得复杂的多。我没有理由去信任你，你也没有理由去信任我。&lt;/p&gt;

&lt;h3 id=&quot;2-签一个法律协议&quot;&gt;2. 签一个法律协议&lt;/h3&gt;

&lt;p&gt;另一个貌似可行的方案是，将我们的赌约正式形成一个有法律效力协议。我们双方签署一个定义了赌约所有细节的协议 – 包括如果输的一方违反协议会怎样。&lt;/p&gt;

&lt;p&gt;这个协议将会使得我们有义务付给赢的一方，但是它没有任何实用性，因为通过合法途径强制协议执行的成本，要比这个赌约的价值高得多。&lt;/p&gt;

&lt;h3 id=&quot;3-请一个共同的朋友帮忙&quot;&gt;3. 请一个共同的朋友帮忙&lt;/h3&gt;

&lt;p&gt;我们可以找一个双方都信得过的朋友，然后各给这个朋友 100 美元进行保管。第二天，他会检查天气，然后把全部的 200 美元给打赌赢的一方。非常简单和方便，除了有一点：如果这个双方都信任的朋友把钱卷走了怎么办？&lt;/p&gt;

&lt;p&gt;现在，我们有了三种不同的方案来实施赌约，但是每种方案都有缺点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;因为是陌生人，所以我们无法信任彼此。&lt;/li&gt;
  &lt;li&gt;强制执行一个协议是如此的昂贵，以至于不具有任何实用性。&lt;/li&gt;
  &lt;li&gt;求助一个共同的朋友同样又会遇到信任的问题。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以太坊的智能合约就是为了解救这个问题。一个智能合约就像是可信赖的共同的朋友，只不过是用代码写的而已。我们可以在以太坊上写一个合约，这个合约从我们双方获得 100 美元的输入，然后在第二天，通过开放的天气 API 来检查天气，并将所有的以太转给赢的一方。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/127313-ff3ff86df9bf269b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;smart contract&quot; /&gt;&lt;/p&gt;

&lt;p&gt;一个合约写好以后，就无法再被编辑或者修改。因此，你可以保证无论合约的内容是什么，它都会无条件执行。&lt;/p&gt;

&lt;p&gt;但是，智能合约是如何执行？跟区块链又有什么关系呢？&lt;/p&gt;

&lt;h2 id=&quot;智能合约是如何与区块链关联的&quot;&gt;智能合约是如何与区块链关联的？&lt;/h2&gt;

&lt;p&gt;无论智能合约何时被执行，它都会在一个区块上被记录为一个交易。概括来讲，一笔以太坊上的交易看起来就像是这样：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/127313-21f58ba2fb5f9a52.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;除了最后的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Data&lt;/code&gt;，其他字段相信大家一眼就能看出来是干什么的。也正是这个 &lt;code class=&quot;highlighter-rouge&quot;&gt;data&lt;/code&gt; 字段，才使得以太坊与众不同。&lt;code class=&quot;highlighter-rouge&quot;&gt;data&lt;/code&gt; 用于记录智能合约的创建和执行，就像记录交易一样。在以太坊区块链上，任何一个块都可能包含以下三种交易：&lt;/p&gt;

&lt;h3 id=&quot;1-从一个人转移到另一个人的普通交易&quot;&gt;1. 从一个人转移到另一个人的普通交易&lt;/h3&gt;

&lt;p&gt;这些普通交易，就像是比特币交易。如果你直接发送以太给你的朋友，那么 data 字段就是空的，这样的交易就是普通交易。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/127313-dd00cf4d2747e7f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;transfer from one user to a human user&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;2-只有发送方却没有接收方&quot;&gt;2. 只有发送方却没有接收方&lt;/h3&gt;

&lt;p&gt;如果一笔交易中没有接收方，这意味着此次交易是用 &lt;code class=&quot;highlighter-rouge&quot;&gt;data&lt;/code&gt; 字段的内容在网络中创建一个智能合约。&lt;code class=&quot;highlighter-rouge&quot;&gt;data&lt;/code&gt; 字段包含了代码，这些代码就像是网络中的其他用户一样。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/127313-5b3c6248875f228a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;transfers of ether from one user to no one&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;3-将以太转到一个智能合约&quot;&gt;3. 将以太转到一个智能合约&lt;/h3&gt;

&lt;p&gt;无论何时，只要一个用户（或是一个智能合约）想要执行一个智能合约，他/她/它 都会创建一个智能合约的交易，并在 &lt;code class=&quot;highlighter-rouge&quot;&gt;data&lt;/code&gt; 字段放置执行指令。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/127313-48bb6da99a09c6c4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;transfers of ether from a user to a smart contract&quot; /&gt;&lt;/p&gt;

&lt;p&gt;与其他区块链一样，无论上面提到的三种事件何时发生，都会被公布到网络中，并且网络中的每个人都会对它进行记录。除了记录，每个节点还会执行智能合约，来使得他们的 EVM 状态与网络的其他部分同步。&lt;/p&gt;

&lt;p&gt;每个节点都执行软件的一部分，因此，使得整个网络像一个巨大（但是缓慢）的分布式电脑。每次无论多么小的执行，都会被记录到区块链上，永久存在。&lt;/p&gt;

&lt;h2 id=&quot;等一下gas-是什么东西&quot;&gt;等一下，Gas 是什么东西？&lt;/h2&gt;

&lt;p&gt;如果用户想要使用和执行智能合约，就必须要为执行该智能合约付出一定费用。这笔费用是给了实际花费了内存，存储，计算和电力等资源来执行合约的节点。&lt;/p&gt;

&lt;p&gt;为了计算智能合约的费用，合约中的每条语句都有收费标准。比如，如果执行的语句用到了节点的内存，这个语句会有一个价格。如果执行一个语句用到了节点的硬盘存储，这些语句又是另一个价格。在这里，定义成本的单位就叫做 Gas。最终，Gas 会通过汇率转换成以太（ETH）。&lt;/p&gt;

&lt;p&gt;无论何时执行一个智能合约，你都必须要定义一个可以花费的 Gas 的最大值。当智能合约执行完成，或是达到了 Gas 的限额，就会停止执行。这是为了避免在智能合约中出现无限循环，防止出现一些反复执行的语句导致程序停滞。&lt;/p&gt;

&lt;p&gt;因为程序员的一些错误，很可能会导致这样的事情发生。所以每次重复执行时，都会消耗掉一些分配的 Gas，因此使得不会出现无限循环这样的事情。没有必要因为程序员的错误，导致一个节点在执行时崩溃。使用 Gas 就解决了这个问题。&lt;/p&gt;

&lt;h2 id=&quot;这就是以太坊&quot;&gt;这就是以太坊&lt;/h2&gt;

&lt;p&gt;以太坊不仅仅是一个用于交易的加密货币，它的实际价值在于其目的 – 以太坊的目的，是为了让人们使用由几千个节点支撑的分布式世界电脑。&lt;/p&gt;

&lt;p&gt;当然，由于每条语句必须被网络的中每个节点所执行，去中心化的分布式电脑会变得很慢，而且很贵。不过，这里所说的慢是跟谁相比较呢？是跟更快，但是由中心化控制的服务器。&lt;/p&gt;

&lt;p&gt;为了能够享受中心化电脑带来的低成本，我们交出了我们的控制权。但是如果中心化服务器宕机或是被黑客攻击，那么所有与它连接的客户端都会挂掉。而一个去中心化的分布式电脑，只有在每个节点都停止工作的情况下，才会挂掉。换句话说，这使得它永远不会宕机。无论在哪里，只要有网络，就有以太坊。&lt;/p&gt;

&lt;p&gt;原文：
&lt;a href=&quot;https://hackernoon.com/wtf-is-ethereum-c65e0d67ac09&quot;&gt;WTF is Ethereum?
The ultimate guide to understand why Ethereum is not just another cryptocurrency.&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 25 Sep 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/Diary/posts/ethereum-ultimate-guide/</link>
        <guid isPermaLink="true">http://localhost:4000/Diary/posts/ethereum-ultimate-guide/</guid>
        
        <category>Ethereum</category>
        
        
        <category>posts</category>
        
      </item>
    
      <item>
        <title>简单了解 Tendermint</title>
        <description>&lt;p&gt;Tendermint 是什么?&lt;/p&gt;

&lt;h3 id=&quot;来自一段-slack-对话&quot;&gt;来自一段 slack 对话&lt;/h3&gt;

&lt;p&gt;先来举个例子，Wordpress  与 Apache Web Server，Apache Web Server 通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;fastcgi&lt;/code&gt; 与 Wordpress 进行交流。它们被组合到一个服务端的进程中，这个进程负责处理连接逻辑，比如控制流量和安全。Tendermint 就像是分布式账本中的 Apache Web Server，它负责了像 p2p 网络，共识，交易广播等等之类的事情。&lt;/p&gt;

&lt;p&gt;对于应用任何商业性质的逻辑处理而言，Tendermint 是透明的。而对 Tendermint 来说，这些逻辑处理也都只不过是二进制的字节而已。一旦网络中的验证人对一个块达成共识，并且想要提交这个块时，交易就会通过 ABCI 被推送到应用中，ABCI 是一个网络套接字协议，它的作用就类似于在 Apache Web Server 与 Wordpress 示例中的 &lt;code class=&quot;highlighter-rouge&quot;&gt;fastcgi&lt;/code&gt;. 没有人知道谁会成为未来分布式账本中的 Wordpress.&lt;/p&gt;

&lt;h3 id=&quot;另一种解释&quot;&gt;另一种解释&lt;/h3&gt;

&lt;p&gt;Tenermint 是一个软件，用于在多台机器安全一致地复制一个应用。所谓安全，指的是即使有多达 1/3 的机器出现任意故障的情况下， Tendermint 仍然能够正常工作。所谓一致，指的是每一个正常工作的机器都会有着同样的交易日志，计算相同的状态。安全一致的复制是分布式系统中一个至关重要的问题：从货币到选举，到基础设施规划，它在广泛应用的容错中承担了一个极其重要的角色。&lt;/p&gt;

&lt;p&gt;能够容忍机器以任何一种，甚至包括危害系统的方式发生故障，被称为拜占庭容错（BFT）。拜占庭理论已经有几十年的历史，但是很大程度上，直到最近像比特币，以太坊这样区块链技术的成功，它的软件实现才得以进一步发展。区块链技术只是以一种现代化的方式对 BFT 的再形式化，而且重点关注 p2p 网络和密码验证。区块链这个名词来源于交易的处理方式，通过区块的批量方式处理交易，每个块包含了前一个块的加密哈希，以此来形成一个链。实际上，区块链数据库真正地优化了 BFT 设计。&lt;/p&gt;

&lt;p&gt;Tendermint 包含了两个主要的技术组件：一个区块链共识引擎和一个通用的应用程序接口。共识引擎，叫做 Tendermint Core，保证了每一台机器以相同的顺序记录同一笔交易。应用程序接口，叫做应用程序区块链接口（ABCI），保证了交易可以通过任何一种编程语言进行处理。与其他预先打包内置状态机（比如键值存储或者一个奇怪的脚本语言）的区块链和共识方案不同，开发者可以使用 Tendermint 实现应用的 BFT 状态机复制，而这些应用可以用任何语言编写，而且开发环境对开发者也十分友好。&lt;/p&gt;

&lt;p&gt;Tendermint 的设计原则是易使用，易理解，高性能，对于各种分布式应用都十分有用。&lt;/p&gt;

&lt;h2 id=&quot;1-tendermint-与其他技术的比较&quot;&gt;1. Tendermint 与其他技术的比较&lt;/h2&gt;

&lt;p&gt;大体上, Tendermint 与两类软件很类似。第一类包含了分布式的键值存储，比如 &lt;a href=&quot;https://zookeeper.apache.org/&quot;&gt;Zookeeper&lt;/a&gt;，&lt;a href=&quot;https://github.com/coreos/etcd&quot;&gt;etcd&lt;/a&gt; 和 &lt;a href=&quot;https://github.com/hashicorp/consul&quot;&gt;consul&lt;/a&gt;，它们都使用了非拜占庭容错共识。第二类就是 “区块链技术”，它既包括了像比特币和以太坊这样的加密货币，也包括了像 Hyperledger &lt;a href=&quot;https://github.com/hyperledger/burrow&quot;&gt;Burrow&lt;/a&gt; 这样的分布式账本设计。&lt;/p&gt;

&lt;h3 id=&quot;zookeeper-etcd-consul&quot;&gt;Zookeeper, etcd, consul&lt;/h3&gt;

&lt;p&gt;Zookeeper，etcd 和 consul 都是在一个经典的非拜占庭容错共识算法上, 实现了一个键值存储。Zookeeper 使用了 Paxos 一个叫做 Zookeeper Atomic Broadcast 的版本，而 etcd 和 consul 则使用了更年轻，也更简单的 Raft 共识算法。一个典型的集群由 3-5 台机器构成，虽然可以承受 1/2 的机器发生问题，但是只要发生一次拜占庭故障，整个系统就可能被摧毁。它们每一个都提供了一个稍微有别于键值存储的实现，但是都将关注点放在提供分布式系统的基础服务上，比如动态配置，服务发现，锁定，领导人选取等等。&lt;/p&gt;

&lt;p&gt;Tendermint 是一个本质上类似的软件，不过有两点关键不同：它是拜占庭容错的，这意味着它可以承受 1/3 机器发生&lt;strong&gt;任意&lt;/strong&gt;形式的故障 – 包括黑客和恶意攻击。&lt;/p&gt;

&lt;p&gt;它并不像键值存储，是针对某一指定类型的应用。相反，它关注于任意的状态机复制，因此开发者可以量身打造适合自己的应用逻辑，从键值存储到加密货币到电子投票平台，甚至更多的应用都可适用。&lt;/p&gt;

&lt;p&gt;以上内容取自于 &lt;a href=&quot;https://www.consul.io/&quot;&gt;consul.io&lt;/a&gt; 和 &lt;a href=&quot;https://www.hashicorp.com/#tools&quot;&gt;Hashicorp sites&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;bitcoin-ethereum-etc&quot;&gt;Bitcoin, Ethereum, etc.&lt;/h3&gt;

&lt;p&gt;在比特币和以太坊这样的传统加密货币下出现了 Tendermint，它的目的在于提供一个比比特币的工作量证明更加有效和安全的共识算法。在早期，Tendermint 内置了一个简单的货币来参与共识，用户必须向一个保证金账户中“绑定”一定数量的货币，如果他们表现不端，这些钱就会被收回 – 这一点使得 Tendermint 成为一个 POS 算法。&lt;/p&gt;

&lt;p&gt;自那时起，Tendermint 就进化为一个能够承载任意应用状态的通用区块链共识引擎。这意味着它可以成为其他区块链软件共识引擎的一个即插即用的替代品。所以基于当前的以太坊代码库，无论是用何种语言， Rust，Go，Haskell，任何人都可以使用 Tendermint 共识运行一个 ABCI 应用。实际上，我们已经完成了这一点(&lt;a href=&quot;https://github.com/tendermint/ethermint&quot;&gt;ethermint&lt;/a&gt;)。此外，我们也计划为 Bitcoin，ZCash，和其他确定性的应用完成同样的工作。另一个基于 Tendermint 构建的加密货币应用是 &lt;a href=&quot;http://cosmos.network/&quot;&gt;Cosmos&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&quot;fabric-burrow&quot;&gt;Fabric, Burrow&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/hyperledger/fabric&quot;&gt;Fabric&lt;/a&gt; 采用了与 Tendermint 类似的方法，但是它更关注对状态的管理，并且要求所有的应用行为能够在多个 docker 容器，叫做 “chaincode” 的模块中运行。它使用了来自 IBM (&lt;a href=&quot;https://www.zurich.ibm.com/~cca/papers/sieve.pdf&quot;&gt;augmented to handle potentially non-deterministic chaincode&lt;/a&gt;) 的 &lt;a href=&quot;http://pmg.csail.mit.edu/papers/osdi99.pdf&quot;&gt;PBFT&lt;/a&gt; 实现。通过扩展 Tendermint 来处理未来工作中存在的不确定性，在 Tendermint 中通过一个 ABCI 应用实现这个基于 docker 的行为是完全有可能的。&lt;a href=&quot;https://github.com/hyperledger/burrow&quot;&gt;Burrow&lt;/a&gt; 是一个以太坊虚拟机和以太坊交易机制的实现，同时附带有名字注册，许可权和天然合约，可替代区块链 API 等额外特性。它使用 Tendermint 作为它的共识引擎，提供一个特殊的应用状态。&lt;/p&gt;

&lt;h2 id=&quot;2-什么是-abci-应用区块链接口&quot;&gt;2. 什么是 ABCI (应用区块链接口)&lt;/h2&gt;

&lt;p&gt;区块链应用接口（Application BlockChain Interface，ABCI）允许应用的拜占庭容错复制可以由任意一种编程语言编写。&lt;/p&gt;

&lt;h3 id=&quot;动机&quot;&gt;动机&lt;/h3&gt;

&lt;p&gt;至今为止，所有的区块链“栈”（比如，&lt;a href=&quot;https://github.com/bitcoin/bitcoin&quot;&gt;比特币&lt;/a&gt;）都有着大一统的设计。这就是说，每个区块链栈都是一个单一的程序，这个程序处理了去中心化账本的所有事务。它还包括了 P2P 连接，交易的“内存池”广播，在最新块上的共识，账户余额，图灵完备的合约，用户级别的许可权等。&lt;/p&gt;

&lt;p&gt;在计算机科学中，使用大一统的架构，是一个典型的错误实践。这会使得代码重用变得困难，而且如果真的去这么做时，会导致代码库分支的维护变得十分复杂。尤其当代码设计并非模块化时，会产生难以维护的“意大利面条式代码”。&lt;/p&gt;

&lt;p&gt;大一统设计的另一个问题是，它限制了区块链栈的语言。比如在以太坊中，它支持一个图灵完备的字节码虚拟机，它限制你必须使用可以编译为那种类型字节码的语言。目前，它所支持的语言是 Serpent 和 Solidity。&lt;/p&gt;

&lt;p&gt;相反，我们的方式是从特定区块链应用的应用状态细节中，将共识引擎和 p2p 层分离开来。我们通过将应用细节抽象为一个借口来实现这一点，这个接口被实现为一个 socket 协议。&lt;/p&gt;

&lt;p&gt;所以，我们就有了一个接口，应用区块链接口（ABCI），和它的主要实现，Tendermint Socket Protocol (TSP, 或 Teaspoon)。&lt;/p&gt;

&lt;h3 id=&quot;abci-介绍&quot;&gt;ABCI 介绍&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/tendermint/tendermint&quot;&gt;Tendermint Core&lt;/a&gt; （“共识引擎”）通过一个满足 &lt;a href=&quot;https://github.com/tendermint/abci&quot;&gt;ABCI&lt;/a&gt; 标准的 socket 协议与应用进行交流。&lt;/p&gt;

&lt;p&gt;举个大家比较熟悉的例子，比特币。比特币是一个加密货币区块链，其中的每个节点维护了一个完全经过审计的 UTXO 数据库。如果有人想要在 ABCI 之上创建一个类似比特币的系统，Tendermint Core 将会负责：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在节点间共享区块和交易&lt;/li&gt;
  &lt;li&gt;建立交易（区块链）的标准/不可变顺序&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;而应用将会负责：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;维护 UTXO 数据库&lt;/li&gt;
  &lt;li&gt;验证交易的加密签名&lt;/li&gt;
  &lt;li&gt;阻止花费尚未存在的交易&lt;/li&gt;
  &lt;li&gt;允许客户端查询 UTXO 数据库&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Tendermint 能够通过在应用过程和共识过程之间，提供一个非常简单的 API （也就是 ABCI）来分解区块链设计。&lt;/p&gt;

&lt;p&gt;ABCI 包含了 3 个主要的消息类型，它们由 core 发送至应用，应用会对消息产生相应的回复。&lt;/p&gt;

&lt;p&gt;消息的详细说明在这里：&lt;a href=&quot;https://github.com/tendermint/abci#message-types&quot;&gt;ABCI 消息类型&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DeliverTx&lt;/code&gt; 消息是应用的主要部分。链中的每笔交易都通过这个消息进行传送。应用需要基于当前状态，应用协议，和交易的加密证书上，去验证接收到 &lt;code class=&quot;highlighter-rouge&quot;&gt;DeliverTx&lt;/code&gt; 消息的每笔交易，。一个经过验证的交易然后需要去更新应用状态 – 比如通过将绑定一个值到键值存储，或者通过更新 UTXO 数据库。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CheckTx&lt;/code&gt; 消息类似于 &lt;code class=&quot;highlighter-rouge&quot;&gt;DeliverTx&lt;/code&gt;，但是它仅用于验证交易。Tendermint Core 的内存池首先通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;CheckTx&lt;/code&gt; 检验一笔交易的有效性，并且只将有效交易中继到其他节点。比如，一个应用可能会检查在交易中不断增长的序列号，如果序列号过时，&lt;code class=&quot;highlighter-rouge&quot;&gt;CheckTx&lt;/code&gt; 就会返回一个错误。又或者，他们可能使用一个基于容量的系统，该系统需要对每笔交易重新更新容量。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Commit&lt;/code&gt; 消息用于计算当前应用状态的一个加密保证（cryptographic commitment），这个加密保证会被放到下一个区块头。这有一些比较方便的属性。现在，更新状态时的不一致性会被认为是区块链的分支，分支会捕获所有的编程错误。这同样也简化了保障轻节点客户端安全的开发，因为 Merkel-hash 证明可以通过在区块哈希上的检查得到验证，区块链哈希由一个 quorum 签署。&lt;/p&gt;

&lt;p&gt;一个应用可能有多个 ABCI socket 连接。Tendermint Core 给应用创建了三个 ABCI 连接：一个用于内存池广播时的交易验证，一个用于运行提交区块时的共识引擎，还有一个用于查询应用状态。&lt;/p&gt;

&lt;p&gt;很显然，在创建区块链时，应用的设计者需要非常小心地设计他们的消息处理，这个架构提供一个范例。下图阐释了通过 ABCI 的消息流：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/Diary/assets/images/posts/tendermint-abci.png&quot; alt=&quot;abci&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;关于确定性的说明&quot;&gt;关于确定性的说明&lt;/h3&gt;

&lt;p&gt;区块链交易处理的逻辑必须是确定性的。如果应用逻辑不确定，就无法在 Tendermint Core 复制节点间达成共识。&lt;/p&gt;

&lt;p&gt;在以太坊上的 Solidity 是用于区块链应用一个非常好的语言选择，除了一些其他因素，它还是一个完全确定性的编程语言。但是，通过使用现有的一些语言，比如 Java，C++，Python 和 Go 也是可以创建确定性应用的。对通过避免非确定性来源创建确定性程序，游戏程序员和区块链开发者都已经很熟悉了，比如：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;随机数生成器（没有确定性的种子）&lt;/li&gt;
  &lt;li&gt;线程上的竞争条件（或者避免多线程）&lt;/li&gt;
  &lt;li&gt;系统时钟&lt;/li&gt;
  &lt;li&gt;未初始化的内存（在像 C 或者 C++ 这样的不安全语言）&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://gafferongames.com/networking-for-game-programmers/floating-point-determinism/&quot;&gt;浮点数算法&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;随机的语言特性（比如 Go 语言的 map 迭代）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;尽管程序员可以通过加倍小心来避免非确定性，但是给每个语言创建一个特殊的语法检查器或静态分析器，用它们来检查确定性也是有可能的。在未来，我们可能会与合作者一起创造出这样的工具。&lt;/p&gt;

&lt;h2 id=&quot;3-共识概览&quot;&gt;3. 共识概览&lt;/h2&gt;

&lt;p&gt;Tendermint 是一个易于理解，大部分操作为异步的 BFT 共识协议。下图是一个简单的状态机，它展示了协议遵循的规则：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/Diary/assets/images/posts/tendermint-state-machine.png&quot; alt=&quot;abci&quot; /&gt;&lt;/p&gt;

&lt;p&gt;协议中的参与者叫着 “验证人”（validator）。他们轮流对交易区块进行提议，并对这些区块进行投票。区块会被提交到链上，每一个块占据一个“高度”（height）。提交块可能会失败，如果失败，协议就会开始下一轮的提交，并且一个新的验证人会继续提交那个高度的区块。要想成功提交一个块，需要有两个阶段的投票：“预投票”（pre-vote）和“预提交”（pre-commit）。在同一轮提交中，只有超过 2/3 的验证人对同一个块进行了预提交，这个块才能被提交到链上。&lt;/p&gt;

&lt;p&gt;上图右下角有一对夫妇在跳波卡舞，因为验证人做的事情就像是在跳波卡舞。当超过 2/3 的验证人对同一个块进行了预投票，我们就把它叫做一个“波卡”（polka）。每一个预提交都必须被同一轮中的一个波卡所证明。&lt;/p&gt;

&lt;p&gt;由于一些原因，验证人可能在提交一个块时失败：当前提议者可能离线了，或者网络非常慢。Tendermint 允许他们证实一个验证人应该被跳过。在进行下一轮的投票前，验证人会等待一小段时间从提议者那里接收一个完整的提议块。这种对于超时的依赖，使得 Tendermint 成为了一个弱同步协议，而非一个异步协议。但是，协议的剩余部分都是异步的，只有在接收到超过 2/3 的验证人集合时，验证人才会采取下一步操作。Tendermint 能够简化的一个原因就是它使用了同样的机制来提交一个块和跳过直接进入下一轮。&lt;/p&gt;

&lt;p&gt;基于不到 1/3 的验证人是拜占庭节点的前提，Tendermint 保证了永远都不会违背其安全性 – 也就是说，验证人永远不会在同一高度提交冲突块。为了达到这一点，它引入了一些 “锁定”（locking）的规则，这些规则对流程图中的路径进行了模块化。一旦一个验证人预提交了一个块，它就被“锁定”在了那个块上。然后，&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;它必须为被锁定的那个块进行预投票&lt;/li&gt;
  &lt;li&gt;只有在之后的轮中，有了那个块的一个波卡，它才能够解锁，并为一个新块进行预提交。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;权益&quot;&gt;权益&lt;/h3&gt;

&lt;p&gt;在许多系统中，并非所有的验证人都在共识协议有着同样的“高度”（height）。因此，我们对 1/3 还是 2/3 的验证人并不十分感兴趣，而是关心在所有投票力量所占的比例，在个体验证人中，这些比例可能并不是均匀分布的。&lt;/p&gt;

&lt;p&gt;由于 Tendermint 可以复制任意的应用程序，定义一种货币，并用该货币来计算投票权力是完全有可能的。当使用货币决定投票权时，这个系统通常叫做权益证明（Proof-of-Stake）系统。通过应用逻辑，可以将验证人的货币持有强制绑定到一个押金账户中。如果他们被发现在共识协议中表现不端，这些钱就会被销毁。这就给协议的安全性增加了一个经济因素，能够让人们量化违反共识假设的成本，这个假设就是只有不到 1/3 的投票权来自拜占庭节点。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://cosmos.network/&quot;&gt;Cosmos Network&lt;/a&gt; 的设计目的，是在实现了 ABCI 应用的加密货币中使用这个权益证明机制。&lt;/p&gt;

&lt;p&gt;原文：&lt;a href=&quot;https://tendermint.com/intro&quot;&gt;Tendermint intro&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 18 Aug 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/Diary/posts/tendermint/</link>
        <guid isPermaLink="true">http://localhost:4000/Diary/posts/tendermint/</guid>
        
        <category>consensus</category>
        
        
        <category>posts</category>
        
      </item>
    
      <item>
        <title>用表情符号解释比特币 (1)</title>
        <description>&lt;p&gt;&lt;img src=&quot;/Diary/assets/images/posts/bitcoin-explained-1.png&quot; alt=&quot;1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;比特币是一个存储和消费数字货币的革命性方式，并且有着变革其他领域的潜力。无须成为一个数学家或密码学家, 你就可以理解它是怎么回事。当开始看到整个系统是如何形成时，你可能会变得十分兴奋。本文是三篇系列文章中的第一篇。&lt;/p&gt;

&lt;p&gt;假设通过互联网给你发送一部电影或是一首歌，我会将一个文件添加到邮件中。一旦我点击了发送，那么你就会收到。收到以后，你可以选择观看这部电影，或者是删除它。你可以对这个电影采取任何操作。&lt;/p&gt;

&lt;p&gt;但是记住：我仍然拥有一份拷贝。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/Diary/assets/images/posts/bitcoin-explained-2.gif&quot; alt=&quot;2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这就是典型地在互联网上数字信息的移动。你并不是真的 &lt;strong&gt;转移（transfer）&lt;/strong&gt; 内容，而是对它进行了 &lt;strong&gt;拷贝（copy）&lt;/strong&gt;。直到目前为止，这种方式都十分行得通：但是这可能有点不太恰当，毕竟复制一首歌或是一部电影并不太可能会对经济造成危害。&lt;/p&gt;

&lt;p&gt;但是现在来考虑一下复制金钱（copy money）。&lt;/p&gt;

&lt;p&gt;如果我给你发送一美元，非常重要的一点是，我无法保留这一美元的副本。通过邮件来产生无限的数字货币，可能一开始看起来很有吸引力，但是如果每个人都开始这么干的话会发生什么事情呢？这会导致肆虐的货币膨胀，从而使得经济因此崩塌。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/Diary/assets/images/posts/bitcoin-explained-3.png&quot; alt=&quot;3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;传统上，在有线传输和使用借记卡的世界里，数字货币是由中心化机构进行跟踪以防止复制。比如说，银行的数据库会确认谁到底拥有了多少钱。这个系统依赖于中心化的机构，我们大都已经熟悉这个概念。当然，这个中心化机构对我们的钱有着绝对的控制权，因为我们的钱只是银行数据库里的一个数字而已。&lt;/p&gt;

&lt;p&gt;但是，如果存在另外一种方式，会发生什么呢？相对于通过不可靠的中心化机构来确认我们的财产所有，如果由一个不是仅由单方控制的分布式机构来保证这些信息，会发生什么呢？如果我们的钱是否有价值，不是因为我们相信被背后政府的力量，而是因为我们相信数学的力量？&lt;/p&gt;

&lt;p&gt;这就引出了比特币。&lt;/p&gt;

&lt;h3 id=&quot;引入比特币&quot;&gt;引入比特币&lt;/h3&gt;

&lt;p&gt;比特币是一个数字货币系统，它并不从属于任何政府或机构。&lt;/p&gt;

&lt;p&gt;这可能会有点令人疑惑，上面说比特币是一个系统，实际上，比特币也是货币本身的代名词。比特币系统创建于 2009 年，但是做为货币单位意义上的比特币却是通过一个叫做 &lt;strong&gt;挖矿&lt;/strong&gt; 的持续过程不断生成。听起来有点像是挖黄金，不过这是 21 世纪的数字黄金。&lt;/p&gt;

&lt;p&gt;在比特币网络中，所有交易都永久记录于一个长长的列表之中，这个列表就叫做区块链。区块链并不是由一个中心的权威机构保护的秘密列表。它是一个分布式的公开列表，每个参与其中的计算机都有一个备份。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/Diary/assets/images/posts/bitcoin-explained-4.png&quot; alt=&quot;4&quot; /&gt;&lt;/p&gt;

&lt;p&gt;比特币区块链是&lt;strong&gt;不可更改&lt;/strong&gt;，&lt;strong&gt;公开&lt;/strong&gt;，&lt;strong&gt;分布式&lt;/strong&gt;的账簿：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;不可更改&lt;/strong&gt;。这是指一旦一个记录已经在区块链中存在了几小时，再去改变或是清除该条记录都是行不通的。因为几个小时以后，会有很多其他交易基于该条记录所构建。要想改变这条记录，就要改变所有基于该记录的所有后续记录，随着后续记录的不断增加，这将变得无法更改。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;公开&lt;/strong&gt;。这是指任何人都能够查看区块链，而不仅仅是银行职员。这并不意味着你可以精确地看到&lt;strong&gt;谁&lt;/strong&gt;正在发送或者接收比特币，因为记录都是&lt;strong&gt;匿名&lt;/strong&gt;的 – 通过使用匿名来模糊实体信息。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;分布式&lt;/strong&gt;。这是指全世界的电脑会维护一个同步的区块链拷贝。并没有主本或副本的概念，所有的拷贝都是相同的。&lt;/p&gt;

&lt;p&gt;最后，&lt;strong&gt;账簿&lt;/strong&gt;指的是区块链是一系列交易的集合。如果知道 Venmo 交易列表的话，你完全可以将区块链看做是 Venmo 的交易列表。&lt;/p&gt;

&lt;p&gt;这个分布式账本之所以叫做“区块链”，是因为每个单一的交易被通过一个更大的单位“区块（block）”进行了整合，而这些区块会被按照顺序相互连接起来。这比一笔一笔的添加交易要快得多，生成一个新的区块大概需要十分钟。&lt;/p&gt;

&lt;p&gt;为了更好的阐释这个不可更改，公开，分布式账本的威力，让我们假设一个常见的场景，这个场景会涉及 5 美元比特币交易。（虽然一个比特币的价值可能会时高时低，但是 5 美元基本上只是一个比特币的一小部分。 ）&lt;/p&gt;

&lt;p&gt;在我们假设的场景中，我的朋友 Flizabeth 给我发送了价值 5 美元的比特币，这笔交易会被记录在区块链中 – 所有的交易都是被记录在区块链中。那么，我就拥有了这 5 美元的比特币，然后我可以把它发送给你，因为区块链的每一个拷贝 Flizabeth 的 5 美元比特币。在这个过程中，我，你，Elizabeth 都没有向一个中心化的权威数据库请求谁拥有多少钱这样的信息，也没有请求任何权限。授权是去中心化的，它存在区块链的每一个拷贝中，无处不在。&lt;/p&gt;

&lt;p&gt;你可能会想问：Elizabeth 是从哪儿获得发给我的比特币？&lt;/p&gt;

&lt;p&gt;一个简单的回答是可能有某个人发给了 Elizabeth 比特币，这也是大多数人得到比特币的方式。&lt;/p&gt;

&lt;p&gt;但是这些比特币最初必然是被创造出来的，那么它是怎么创造出来的呢？&lt;/p&gt;

&lt;h3 id=&quot;一个比特币是如何诞生的&quot;&gt;一个比特币是如何诞生的&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/Diary/assets/images/posts/bitcoin-explained-5.png&quot; alt=&quot;5&quot; /&gt;&lt;/p&gt;

&lt;p&gt;美元是由美国政府印刷的，其他传统货币也是由它们的政府发行而来。很久以前，美元是由在美国财政部等量的黄金支持的。在那段时间，要想创造更多货币就需要更多等量的黄金，因此挖黄金十分流行。&lt;/p&gt;

&lt;p&gt;比特币也是通过一个叫做 &lt;strong&gt;挖矿&lt;/strong&gt; 的过程而来。它是数字挖矿，是通过计算机和软件，而不是炸药和铁铲。为了能够将新一个新的区块加入到区块链中，必须要解决一个非常困难的数学题。第一个解决了这个难题的“矿工”就会获得新创造出来的比特币。这就是比特币的挖矿。&lt;/p&gt;

&lt;p&gt;换句话说，挖矿做了两件事：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;向区块链中加入新的区块&lt;/li&gt;
  &lt;li&gt;创造新的比特币&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;矿工竞相解决的数学难题是一个叫做“哈希”的问题。&lt;/p&gt;

&lt;h3 id=&quot;初见哈希&quot;&gt;初见哈希&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/Diary/assets/images/posts/bitcoin-explained-6.png&quot; alt=&quot;6&quot; /&gt;&lt;/p&gt;

&lt;p&gt;一个哈希就是一个数字指纹，因为它唯一识别了一串数字信息 – 无论该信息是一张图片，一个图片相册，一部电影，一串密码，文本，还是其他的任何内容。它是由数字信息经过一个叫做“哈希”的过程衍生而来。它的形式可以是一串字母，数字和其他符号。&lt;/p&gt;

&lt;p&gt;哈希是计算机科学中的核心概念之一，广泛用于诸多场景。为了增强安全性，在线服务经常会存储密码的哈希而不是实际的密码信息，当你登录的时候， 系统会比较密码的哈希而非原始密码。Facebook 使用哈希来检查上传图片是否违规。在 Facebook，不会有人真的用肉眼检查每张照片是否是暴力或色情图片。相反，Facebook 会预先针对被认为是违规的图片，进行哈希，创建一个违规内容的哈希列表。每当一个新的图片被上传到Facebook，它会被同样的函数生成一个哈希。产生的结果哈希会与违禁内容的哈希相互比较 – 如果它们相匹配，Facebook 就会知道这个图片是违禁照片。&lt;/p&gt;

&lt;p&gt;典型地，当软件执行一个哈希函数时，它会接受输入数据 – 比如一张照片 – 然后输出一个天书一样的字符串，这个字符串就是哈希了。&lt;/p&gt;

&lt;p&gt;举个例子，我们用叫做 &lt;a href=&quot;https://en.wikipedia.org/wiki/SHA-2&quot;&gt;SHA-256&lt;/a&gt; 的一个哈希函数来计算一个小狗图片的哈希。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/Diary/assets/images/posts/bitcoin-explained-7.jpeg&quot; alt=&quot;7&quot; /&gt;&lt;/p&gt;

&lt;p&gt;显然，大家应该都能看得出，这张小狗的图片不会是 Facebook 的违禁图片。不过，Facebook 里面的人不会真的去看这张照片，而是使用相关程序检测这张图片的哈希，如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
8EC9D4718F919C6087CA589EDA09E7DD9A7ACCDB820F42B4196E1D0D4BEDE77A

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这就是上面那张图片的 SHA-256 哈希结果，采用 16 进制表示。是不是没有之前的小狗可爱了:).&lt;/p&gt;

&lt;p&gt;哈希函数一个非常有趣的特性是，只要我们稍微改变一下输入，输出就会完全不同。比如，如果我们改变这张图片的一个像素点，在小狗的眼睛上面放一个跳蚤大的黑色像素点：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/Diary/assets/images/posts/bitcoin-explained-8.png&quot; alt=&quot;8&quot; /&gt;&lt;/p&gt;

&lt;p&gt;尽管只是改了一个像素值，但是再次对图片进行哈希，我们会得到一个完全不同的哈希值，：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
039E1AF92F7D00775ECE35C2216FC3F7F0BBCD31F912A105D2601380D8DEABA2

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;现在，接下来我们应该使用真实内容和真实的哈希值了，但是由于哈希的表现形式不太友好，肉眼很难进行鉴别和区分。故而，我们使用表情符号（emoji）来代表输入和输出。在上面的例子中，我们用猫脸来表示输入（content to be hashed）,绶带表示输出（结果哈希）：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/Diary/assets/images/posts/bitcoin-explained-9.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;想象Facebook在两张违禁图片 🚫  和 ❌ , 执行一个哈希函数，得到结果哈希  💩  和 💀 。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/Diary/assets/images/posts/bitcoin-explained-10.png&quot; alt=&quot;9&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然后，有人上传了一张图片 ? ，因为 Facebook 还不知道它是否违规，所以 Facebook 会调用程序对图片进行哈希，结果是&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/Diary/assets/images/posts/bitcoin-explained-11.png&quot; alt=&quot;10&quot; /&gt;&lt;/p&gt;

&lt;p&gt;尽管没有人真的去用肉眼观测过这张图片，但是 Facebook 已经知道它属于违禁图片，因此图片的哈希匹配了。没有人需要去直接查看新上传的输入，只要它有着与已有违禁图片的相同哈希，我们就认为这是违规图片。&lt;/p&gt;

&lt;p&gt;图片识别仅仅是哈希的其中一个应用。创造新的比特币和将新的交易加入到区块链中的比特币挖矿，是另一个应用。&lt;/p&gt;

&lt;p&gt;至此，在本系列的第一篇，我们知道了比特币是一个去中心化的货币，并非由任何的政府或金融机构发行，还知道了什么是哈希。在下一篇，我们将会了解比特币矿工是如何利用哈希来创造比特币，密码学是如何在完全可转移且不可逆的情况下，使得比特币具有唯一性和不可复制性。&lt;/p&gt;

&lt;p&gt;原文：&lt;a href=&quot;https://medium.com/@tessr/making-money-530d2bb2b8f7&quot;&gt;Bitcoin Explained (with Emoji)&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 30 Jul 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/Diary/posts/bitcoin-explained-1/</link>
        <guid isPermaLink="true">http://localhost:4000/Diary/posts/bitcoin-explained-1/</guid>
        
        <category>bitcoin</category>
        
        
        <category>posts</category>
        
      </item>
    
      <item>
        <title>用异步协程写一个爬虫 (2)</title>
        <description>&lt;p&gt;本文译自： &lt;a href=&quot;http://www.aosabook.org/en/500L/a-web-crawler-with-asyncio-coroutines.html&quot;&gt;A Web Crawler With asyncio Coroutines&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;在上一篇的最后, 我们提到了多线程与异步的一些问题, 下面来介绍一下 Python 的协程(coroutines), 它兼具了多线程与异步的一些优点.&lt;/p&gt;

&lt;h3 id=&quot;coroutines&quot;&gt;Coroutines&lt;/h3&gt;

&lt;p&gt;其实是存在 “美貌与智慧” 兼得的方法的。 将回调的有效性与多线程程序的经典好处结合到一起的异步代码是很有可能的。其方法就是使用叫做 “协程(coroutines)” 的模式。使用 Python3.4 中的标准 asyncio 库，和一个叫做 “aiohttp” 的 package, 在一个协程中获取一个 URL 非常直观：&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;nd&quot;&gt;@asyncio.coroutines&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;fetch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;response&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;session&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;body&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;response&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;它同时还具有伸缩性 (scalable)。 与每个线程 50k 的内存消耗与操作系统对于线程的严格限制相比，一个 Python 的协程仅仅消耗 3k . Python 可以轻松地启动成百上千的协程。&lt;/p&gt;

&lt;p&gt;协程的概念其实很简单: 它是一个能够被暂停和重新启动的子程序。尽管线程被操作系统抢占式的多任务安排，协程的多任务是协作式的：它们选择合适暂停，然后下一次运行哪一个协程。&lt;/p&gt;

&lt;p&gt;协程有许多实现，即使是在 Python 中也有好几个实现。在 Python3.4 的标准 “asyncio” 库中， 协程基于生成器，使用了 “yield from” 声明. 自从 Python 3.5 , 线程已经成为语言的一个天然特性。不过，理解在 Python  3.4 中首先实现的协程，使用预先存在的语言功能，是利用 Python 3.5 天然协程的基础。&lt;/p&gt;

&lt;p&gt;为了解释 Python 3.4 中基于生成器的协程，我们将会阐述生成器是什么以及在 asyncio 它们是如何用作协程。相信你跟我们乐于书写这部分一样乐于阅读. 一旦解释完基于生成器的协程，我们将会在我们的异步网络爬虫中使用它们。&lt;/p&gt;

&lt;h3 id=&quot;how-python-generators-work&quot;&gt;How Python Generators Work&lt;/h3&gt;

&lt;p&gt;在理解 Python 的生成器之前，你必须要理解普通的 Python 函数是如何工作的。 通常来说，当一个Python 函数调用一个 subroutine 时，这个 subroutine 会保留控制直到返回或是抛出一个异常。然后控制返回给调用者：&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;bar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;bar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;     &lt;span class=&quot;k&quot;&gt;pass&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;标准的 Python 解释器使用 C 写的。执行一个 Python 函数的 C 函数叫做 &lt;code class=&quot;highlighter-rouge&quot;&gt;PyEval_EvalFrameEx&lt;/code&gt;. 它需要一个 Python stack frame 对象，在 frame 的上下文中对 Python 字节码进行求值。 这里是 &lt;code class=&quot;highlighter-rouge&quot;&gt;foo&lt;/code&gt; 的字节码:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;dis&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dis&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dis&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;           &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LOAD_GLOBAL&lt;/span&gt;              &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
              &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CALL_FUNCTION&lt;/span&gt;            &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;positional&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;keyword&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pair&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
              &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;POP_TOP&lt;/span&gt;
              &lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LOAD_CONST&lt;/span&gt;               &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
             &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RETURN_VALUE&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;foo&lt;/code&gt; 函数将 &lt;code class=&quot;highlighter-rouge&quot;&gt;bar&lt;/code&gt; 加载到栈上然后进行调用，并将其从栈上弹出返回值，将 &lt;code class=&quot;highlighter-rouge&quot;&gt;None&lt;/code&gt; 入栈，返回 &lt;code class=&quot;highlighter-rouge&quot;&gt;None&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;当 &lt;code class=&quot;highlighter-rouge&quot;&gt;PyEval_EvalFrameEx&lt;/code&gt; 遇到 &lt;code class=&quot;highlighter-rouge&quot;&gt;CALL_FUNCTION&lt;/code&gt; 字节码，它会调用一个新的 Python stack frame 然后递归: 也就是说，它在新的 frame 下递归地调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;PyEval_EvalFrameEx&lt;/code&gt; , 以此来执行 &lt;code class=&quot;highlighter-rouge&quot;&gt;bar&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;非常重要的一点是要知道 Python stack frame 是分配于堆内存上！ Python 解释器是一个普通的 C 程序而已，所以它的的 stack  frame 也是正常的 stack frame. 但是它控制的 &lt;em&gt;Python stack&lt;/em&gt; frame 在堆上。除了其他惊喜，这还意味着一个 Python stack frame 能够比它的函数调用存活时间更长。 为了交互式地观察这一点，在 &lt;code class=&quot;highlighter-rouge&quot;&gt;bar&lt;/code&gt; 内部保存当前的 frame:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;inspect&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;frame&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;bar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;bar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;     &lt;span class=&quot;k&quot;&gt;global&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;frame&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;frame&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inspect&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;currentframe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# The frame was executing the code for 'bar'.&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;frame&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f_code&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;co_name&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;'bar'&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# Its back pointer refers to the frame for 'foo'.&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;caller_frame&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;frame&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f_back&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;caller_frame&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f_code&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;co_name&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;'foo'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/Diary/assets/images/posts/function-calls.png&quot; alt=&quot;function-calls&quot; /&gt;&lt;/p&gt;

&lt;p&gt;现在开始设置 Python 生成器的阶段，它使用了同样的 building  block - code objects and stack frames - 效果非凡。&lt;/p&gt;

&lt;p&gt;这是一个生成器函数:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;gen_fn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;     &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'result of yield: {}'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;format&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;result2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;     &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'result of 2nd yield: {}'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;format&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;     &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'done'&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;当Python把 &lt;code class=&quot;highlighter-rouge&quot;&gt;gen_fn&lt;/code&gt; 编译为字节码，它会看到 &lt;code class=&quot;highlighter-rouge&quot;&gt;yield&lt;/code&gt; 并且知道 &lt;code class=&quot;highlighter-rouge&quot;&gt;gen_fn&lt;/code&gt; 是一个生成器函数，而不是普通函数。那么他就会设置一个标记:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# The generator flag is bit position 5.&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;generator_bit&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;bool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gen_fn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__code__&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;co_flags&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;generator_bit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;当你调用一个生成器函数时， Python 看到生成器标志，它并不会真正的运行这个函数，而是创建一个生成器：&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gen&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gen_fn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;generator&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'&amp;gt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;一个 Python 生成器封装了一个 stack  frame 和对某些代码的引用， &lt;code class=&quot;highlighter-rouge&quot;&gt;gen_fn&lt;/code&gt; 的主体:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gen&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gi_code&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;co_name&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;'gen_fn'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;对 &lt;code class=&quot;highlighter-rouge&quot;&gt;gen_fn&lt;/code&gt; 的调用的所有生成器都指向同样的代码。但是每一个都拥有自己的 stack frame. 这个 stack frame 并不是任何真正的栈，它位于堆内存并且等待被使用:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/Diary/assets/images/posts/generator.png&quot; alt=&quot;function-calls&quot; /&gt;&lt;/p&gt;

&lt;p&gt;frame 有一个 “最近指令 (last instruction)” 指针，它最近执行最多的指令。开始的时候，最近指令指针为 -1， 表示生成器还没有开始：&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gen&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gi_frame&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f_lasti&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;当我们调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;send&lt;/code&gt; , 生成器到底它的第一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;yield&lt;/code&gt;, 然后暂停。&lt;code class=&quot;highlighter-rouge&quot;&gt;send&lt;/code&gt; 的返回值为 1， 因此这就是 &lt;code class=&quot;highlighter-rouge&quot;&gt;gen&lt;/code&gt; 传递给 &lt;code class=&quot;highlighter-rouge&quot;&gt;yield&lt;/code&gt; 表达式的值：&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gen&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;send&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;生成器的指令指针现在距离开始 3 个字节码， 编译后的Python 56 个字节:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gen&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gi_frame&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f_lasti&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gen&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gi_code&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;co_code&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;56&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;生成器可以在任何时间，从任何函数中重新开始，因为它的 stack frame 实际上并没有在栈上: 它在堆上。它在调用继承上的位置并不是固定的，它也不需要像普通函数那样遵循先进后出的执行顺序。 它是自由的，没有任何限制。&lt;/p&gt;

&lt;p&gt;我们可以发送 “hello” 给生成器，那么 “hello” 会成为 &lt;code class=&quot;highlighter-rouge&quot;&gt;yield&lt;/code&gt; 表达式的结果， 生成器会一直持续直到它产生 2:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gen&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;send&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'hello'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;yield&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hello&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;它的 stack frame 现在包含了本地变量 &lt;code class=&quot;highlighter-rouge&quot;&gt;result&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gen&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gi_frame&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f_locals&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'result'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'hello'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;由 &lt;code class=&quot;highlighter-rouge&quot;&gt;gen_fn&lt;/code&gt; 创建的其他生成器将会拥有它们自己独立的 stack  frame 和 本地变量。&lt;/p&gt;

&lt;p&gt;当我们再次调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;send&lt;/code&gt; 时，生成器将会从第二个 &lt;code class=&quot;highlighter-rouge&quot;&gt;yield&lt;/code&gt; 继续，并且最终抛出一个特殊的 &lt;code class=&quot;highlighter-rouge&quot;&gt;StopIteration&lt;/code&gt; 异常:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gen&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;send&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'goodbye'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nd&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;yield&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;goodbye&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Traceback&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;most&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;recent&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;call&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;last&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;File&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&amp;lt;input&amp;gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;line&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;StopIteration&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;done&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个异常有一个值，这个值就是生成器的返回值: 字符串 &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;done&quot;&lt;/code&gt; .&lt;/p&gt;

&lt;h3 id=&quot;building-coroutines-with-generators&quot;&gt;Building Coroutines With Generators&lt;/h3&gt;

&lt;p&gt;所以一个生成器可以暂停, 通过一个值来重新启动，并且有一个返回值。听起来像是可以基于此来构建一个异步程序模型的一个不错的原型，而不必烦人的回调！ 我们想要构建一个 “协程”: 一个能够与程序中其他协程合作调度的协程。我们的协程将是一个 Python 标准库 “asyncio” 的相应内容的简化版本。在 asyncio 中，我们将会使用生成器，futures, 和 “yield from” 语句。&lt;/p&gt;

&lt;p&gt;首先我们需要有一个方式来表示一个协程等待的未知的结果。 简化版本:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Future&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;
        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_callbacks&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;add_done_callback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_callbacks&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;set_result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_callbacks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;fn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;一个 future 初始为 “pending”. 通过一个队 &lt;code class=&quot;highlighter-rouge&quot;&gt;set_result&lt;/code&gt; &lt;sup id=&quot;fnref:9&quot;&gt;&lt;a href=&quot;#fn:9&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt; 的调用来 “解决” 。&lt;/p&gt;

&lt;p&gt;让我们调整 fetcher 来使用 future 和 协程。 写一个带有回调的 &lt;code class=&quot;highlighter-rouge&quot;&gt;fetch&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Fetcher&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;fetch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sock&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;setblocking&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;False&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;connect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'xkcd.com'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;80&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;except&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BlockingIOError&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;pass&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;selector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;register&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fileno&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt;
                          &lt;span class=&quot;n&quot;&gt;EVENT_WRITE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                          &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;connected&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;connected&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'connected!'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;# And so on....&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;fetch&lt;/code&gt; 以连接一个 socket 开始，然后注册回调， &lt;code class=&quot;highlighter-rouge&quot;&gt;connected&lt;/code&gt;, 当 socket 准备好以后执行。 现在我们尅将这两步组合到一个协程中:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;fetch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;sock&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;sock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;setblocking&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;False&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;sock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;connect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'xkcd.com'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;80&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;except&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BlockingIOError&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;pass&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Future&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;on_connected&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set_result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;selector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;register&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fileno&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt;
                          &lt;span class=&quot;n&quot;&gt;EVENT_WRITE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                          &lt;span class=&quot;n&quot;&gt;on_connected&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;selector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unregister&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fileno&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'connected!'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;现在的 &lt;code class=&quot;highlighter-rouge&quot;&gt;fetch&lt;/code&gt; 是一个生成器函数，而非一个普通函数，因为它包含了一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;yield&lt;/code&gt; 语句。 我们创建一个挂起的 future, 然后生成它来暂停 &lt;code class=&quot;highlighter-rouge&quot;&gt;fetch&lt;/code&gt; 直到 socket 准备好。 内部函数 &lt;code class=&quot;highlighter-rouge&quot;&gt;on_connected&lt;/code&gt; 解析 future.&lt;/p&gt;

&lt;p&gt;当时当 future 解析的时候，什么来重新启动生成器？我们需要一个协程 “驱动器 (driver)”. 就叫它 “task” 吧.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Task&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;coro&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;coro&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;coro&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Future&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set_result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;step&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;step&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;future&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;next_future&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;coro&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;send&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;future&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;except&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;StopIteration&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;next_future&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;add_done_callback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;step&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# Begin fetching http://xkcd.com/353/&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;fetcher&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Fetcher&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'/353/'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Task&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fetcher&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fetch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;loop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;通过发送 &lt;code class=&quot;highlighter-rouge&quot;&gt;None&lt;/code&gt; 给 task 来启动 &lt;code class=&quot;highlighter-rouge&quot;&gt;fetch&lt;/code&gt; 生成器。 然后 &lt;code class=&quot;highlighter-rouge&quot;&gt;fetch&lt;/code&gt; 运行直至它生成一个 future, 同时会被 task 捕获为 &lt;code class=&quot;highlighter-rouge&quot;&gt;next_future&lt;/code&gt; .&lt;/p&gt;

&lt;h3 id=&quot;coordinating-coroutines&quot;&gt;Coordinating Coroutines&lt;/h3&gt;

&lt;p&gt;一旦 socket 连接上，我们就发送 HTTP GET 请求并读取服务器的响应。 这些步骤不再需要分散于回调之间; 我们可以将它们组合到同一个生成器函数中:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;fetch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;# ... connection logic from above, then:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;sock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;send&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;encode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'ascii'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Future&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

            &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;on_readable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set_result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;recv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4096&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;

            &lt;span class=&quot;n&quot;&gt;selector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;register&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fileno&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt;
                              &lt;span class=&quot;n&quot;&gt;EVENT_READ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                              &lt;span class=&quot;n&quot;&gt;on_readable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;chunk&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;selector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unregister&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fileno&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;chunk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;response&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;chunk&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                &lt;span class=&quot;c&quot;&gt;# Done reading.&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这段代码，读了 socket 的全部消息，似乎通常都很有用。 我们如何才能将它从 &lt;code class=&quot;highlighter-rouge&quot;&gt;fetch&lt;/code&gt; 分离并填充到一个协程中?  现在 Python 3 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;yield from&lt;/code&gt; 能够完成这个任务。它允许一个生成器委托另一个生成器.&lt;/p&gt;

&lt;p&gt;为了理解为何如此，让我们回到一个简单的生成器示例：&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;gen_fn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;     &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'result of yield: {}'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;format&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;result2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;     &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'result of 2nd yield: {}'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;format&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;     &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'done'&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;从另一个的生成器中调用这个生成器，使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;yield from&lt;/code&gt; 委托给它:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# Generator function:&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;caller_fn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;gen&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gen_fn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;rv&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gen&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;     &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'return value of yield-from: {}'&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;           &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;format&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# Make a generator from the&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# generator function.&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;caller&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;caller_fn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;caller&lt;/code&gt; 生成器表现地就如同 &lt;code class=&quot;highlighter-rouge&quot;&gt;gen&lt;/code&gt;,它所委托的生成器:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;caller&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;send&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;caller&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gi_frame&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f_lasti&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;15&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;caller&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;send&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'hello'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;yield&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hello&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;caller&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gi_frame&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f_lasti&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;# Hasn't advanced.&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;15&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;caller&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;send&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'goodbye'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nd&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;yield&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;goodbye&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;yield&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;done&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Traceback&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;most&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;recent&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;call&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;last&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;File&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&amp;lt;input&amp;gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;line&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;StopIteration&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;当 &lt;code class=&quot;highlighter-rouge&quot;&gt;caller&lt;/code&gt; 生成自 &lt;code class=&quot;highlighter-rouge&quot;&gt;gen&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;caller&lt;/code&gt; 并不优先。 注意到它的指令指针停留在 15，&lt;code class=&quot;highlighter-rouge&quot;&gt;yield from&lt;/code&gt; 语句的地方，即使是当内部的生成器 &lt;code class=&quot;highlighter-rouge&quot;&gt;gen&lt;/code&gt; 先于一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;yield&lt;/code&gt; 语句进行到下一个 &lt;sup id=&quot;fnref:10&quot;&gt;&lt;a href=&quot;#fn:10&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;。 从我们的视角来看 &lt;code class=&quot;highlighter-rouge&quot;&gt;caller&lt;/code&gt;, 我们无法区分它所产生的值是来自 &lt;code class=&quot;highlighter-rouge&quot;&gt;caller&lt;/code&gt; 还是它所代表的生成器。 从内部的 &lt;code class=&quot;highlighter-rouge&quot;&gt;gen&lt;/code&gt;, 我们无法区分值是发送自 &lt;code class=&quot;highlighter-rouge&quot;&gt;caller&lt;/code&gt; 还是 &lt;code class=&quot;highlighter-rouge&quot;&gt;caller&lt;/code&gt; 外部。 &lt;code class=&quot;highlighter-rouge&quot;&gt;yield from&lt;/code&gt; 语句是一个无摩擦的通道，尽管这些值会流入流出 &lt;code class=&quot;highlighter-rouge&quot;&gt;gen&lt;/code&gt; 直到 &lt;code class=&quot;highlighter-rouge&quot;&gt;gen&lt;/code&gt; 完成。&lt;/p&gt;

&lt;p&gt;一个协程可以通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;yield from&lt;/code&gt; 将工作委托给一个子协程并接受任务结果。 注意，上面的 &lt;code class=&quot;highlighter-rouge&quot;&gt;caller&lt;/code&gt; 打印出 “return value of yield-from: done” . 当 &lt;code class=&quot;highlighter-rouge&quot;&gt;gen&lt;/code&gt; 完成后， 它的返回值变成了 &lt;code class=&quot;highlighter-rouge&quot;&gt;caller&lt;/code&gt; 里面的 &lt;code class=&quot;highlighter-rouge&quot;&gt;yield from&lt;/code&gt; 语句的返回值:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;n&quot;&gt;rv&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gen&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;早先，我们批评了基于回调的异步程序的不足之处，最大的一个缺点是 “stack ripping”: 当一个回调抛出异常时，追踪栈通常并没有什么用。 它只是显示出事件循环正在运行回调，却没有指示 &lt;em&gt;为什么&lt;/em&gt; 。 那么协程如何呢?&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;gen_fn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;     &lt;span class=&quot;k&quot;&gt;raise&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Exception&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'my error'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;caller&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;caller_fn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;caller&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;send&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Traceback&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;most&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;recent&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;call&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;last&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;File&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&amp;lt;input&amp;gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;line&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;File&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&amp;lt;input&amp;gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;line&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;caller_fn&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;File&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&amp;lt;input&amp;gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;line&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gen_fn&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;Exception&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;my&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;error&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这些信息相当有用！追踪栈显示 &lt;code class=&quot;highlighter-rouge&quot;&gt;caller_fn&lt;/code&gt; 委托了 &lt;code class=&quot;highlighter-rouge&quot;&gt;gen_fn&lt;/code&gt; 当它抛出错误的时候。 更有效的是，我们可以将子协程的调用包装在一个异常的 handler 猴子那个，同样适用于正常的子协程:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;gen_fn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;     &lt;span class=&quot;k&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;     &lt;span class=&quot;k&quot;&gt;raise&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Exception&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'uh oh'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;caller_fn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;     &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;         &lt;span class=&quot;k&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gen_fn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;     &lt;span class=&quot;k&quot;&gt;except&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;exc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;         &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'caught {}'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;format&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;exc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;caller&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;caller_fn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;caller&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;send&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;caller&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;send&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'hello'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;caught&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uh&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;oh&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;所以我们使用子协程来分离逻辑就像使用普通的子协程一样。 让我们从 fetcher 中分离一些有用的子协程。 我们写一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;read&lt;/code&gt; 协程来接收一个数据块:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Future&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;on_readable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set_result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;recv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4096&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;selector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;register&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fileno&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EVENT_READ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;on_readable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;chunk&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;# Read one chunk.&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;selector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unregister&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fileno&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;chunk&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;基于 &lt;code class=&quot;highlighter-rouge&quot;&gt;read&lt;/code&gt; 我们使用了 &lt;code class=&quot;highlighter-rouge&quot;&gt;read_all&lt;/code&gt; 协程来获取一个完整的消息:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;read_all&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;response&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;# Read whole response.&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;chunk&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;chunk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;response&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;chunk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;chunk&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;''&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;response&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果你仔细看的话，&lt;code class=&quot;highlighter-rouge&quot;&gt;yield from&lt;/code&gt; 语句不见了，它们看起来就像是执行阻塞时 I/O 的传统程序。 但是实际上，&lt;code class=&quot;highlighter-rouge&quot;&gt;read&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;read_all&lt;/code&gt; 都是协程。 &lt;code class=&quot;highlighter-rouge&quot;&gt;read&lt;/code&gt; 所产生的内容会暂停 &lt;code class=&quot;highlighter-rouge&quot;&gt;read_all&lt;/code&gt; 直到 I/O 完成. 当 &lt;code class=&quot;highlighter-rouge&quot;&gt;read_all&lt;/code&gt; 暂停后，asyncio 的事件循环会做其他事情和等到其他的 I/O 事件; 一旦它的事件准备好了，&lt;code class=&quot;highlighter-rouge&quot;&gt;read_all&lt;/code&gt; 就会以下一个循环 tick 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;read&lt;/code&gt; 的结果重新开始。&lt;/p&gt;

&lt;p&gt;在栈底, &lt;code class=&quot;highlighter-rouge&quot;&gt;fetch&lt;/code&gt; 调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;read_all&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Fetcher&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;fetch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
         &lt;span class=&quot;c&quot;&gt;# ... connection logic from above, then:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;sock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;send&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;encode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'ascii'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;response&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;read_all&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;出乎意料地，Task 类并不需要有所改变。它会像之前一样驱动外部的 &lt;code class=&quot;highlighter-rouge&quot;&gt;fetch&lt;/code&gt; 协程:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Task&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fetcher&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fetch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;loop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;当 &lt;code class=&quot;highlighter-rouge&quot;&gt;read&lt;/code&gt; 生成一个 future, task 通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;yield from&lt;/code&gt; 语句的通道接收 future, 更准确地说，就想好事 future 直接产生自 &lt;code class=&quot;highlighter-rouge&quot;&gt;fetch&lt;/code&gt;. 当循环解析一个 future, task 将它的结果发送给 &lt;code class=&quot;highlighter-rouge&quot;&gt;fetch&lt;/code&gt;, 并且值被 &lt;code class=&quot;highlighter-rouge&quot;&gt;read&lt;/code&gt; 所接收, 跟 task 直接驱动 &lt;code class=&quot;highlighter-rouge&quot;&gt;read&lt;/code&gt; 一样:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/Diary/assets/images/posts/yield-from.png&quot; alt=&quot;yield-from&quot; /&gt;&lt;/p&gt;

&lt;p&gt;为了完善我们的协程实现， 我们去除一个缺点： 当等待一个 future 时使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;yield&lt;/code&gt;, 但是当它委托给一个子协程时使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;yield from&lt;/code&gt;. 如果无论当一个协程何时暂停，我们都使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;yield from&lt;/code&gt; 就更好了。那么一个协程就不再需要考虑它所等待的是一个什么类型的东西.&lt;/p&gt;

&lt;p&gt;我们利用了 Python 中生成器与迭代器之间的深层次联系。 对 caller 来说，生成器很高级， 迭代器同样很高级。所以我们通过实现一个特殊的方法来使得 Future 类可迭代:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;c&quot;&gt;# Method on Future class.&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;__iter__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;# Tell Task to resume me here.&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;future 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;__iter__&lt;/code&gt; 方法是一个产生 future 自身的协程。 现在我们来替换像这样的代码:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# f is a Future.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;用这样的来替换:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# f is a Future.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;…结果是一样的！ 驱动 Task 从它对 &lt;code class=&quot;highlighter-rouge&quot;&gt;send&lt;/code&gt; 的调用中接收 future, 当 future 被解析后它将新的结果返回给协程。&lt;/p&gt;

&lt;p&gt;到处使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;yield from&lt;/code&gt; 有什么好处呢? 为什么使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;yield&lt;/code&gt; 等待 future 和使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;yield from&lt;/code&gt; 委托给子协程更好？ 它更好是因为，一个方法可以不影响 caller 而自由地改变它的实现: 它可能是一个普通的方法，返回将会 &lt;em&gt;解析&lt;/em&gt; 为一个值的 future , 或者它可能是一个包含了 &lt;code class=&quot;highlighter-rouge&quot;&gt;yield from&lt;/code&gt; 语句的协程，并且 &lt;em&gt;返回&lt;/em&gt; 了一个值。 无论是哪种情况，caller 仅需要从方法中 &lt;code class=&quot;highlighter-rouge&quot;&gt;yeild from&lt;/code&gt; 以此来等待结果。&lt;/p&gt;

&lt;p&gt;至此，我们到了 asyncio 中协程的尾部。 我们仔细了解了生成器的工作机制，大概勾勒了 future 和 task 的实现。 当然了，实际的 asyncio  要比我们勾勒的版本要复杂得多。真正的框架解决了 另附纸 I/O, 公平安排，异常捕获和一些其他丰富的特性。&lt;/p&gt;

&lt;p&gt;对于 asyncio 的用户而言， 使用协程来写程序要比上面看到的要简单得多。 在上面的代码中，我们从第一个原则起实现了一个协程，里面包括了 callback, task 和 future. 你甚至看到了非阻塞式的 socket 和对于 &lt;code class=&quot;highlighter-rouge&quot;&gt;select&lt;/code&gt; 的调用。 但是当使用 asyncio 来真正构建一个应用时， 上面的代码并不会出现。如我们所望，你可以像下面一样简洁地获取一个 URL:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
    &lt;span class=&quot;nd&quot;&gt;@asyncio.coroutine&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;fetch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;response&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;session&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;body&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;response&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;对于协程的阐述到此告一段落，下面回到一开始的任务: 使用 asyncio 写一个异步爬虫.&lt;/p&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:9&quot;&gt;
      &lt;p&gt;This future has many deficiencies. For example, once this future is resolved, a coroutine that yields it should resume immediately instead of pausing, but with our code it does not. See asyncio’s Future class for a complete implementation.↩ &lt;a href=&quot;#fnref:9&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:10&quot;&gt;
      &lt;p&gt;In fact, this is exactly how “yield from” works in CPython. A function increments its instruction pointer before executing each statement. But after the outer generator executes “yield from”, it subtracts 1 from its instruction pointer to keep itself pinned at the “yield from” statement. Then it yields to its caller. The cycle repeats until the inner generator throws StopIteration, at which point the outer generator finally allows itself to advance to the next instruction.↩ &lt;a href=&quot;#fnref:10&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
        <pubDate>Sat, 10 Jun 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/Diary/posts/a-web-crawer-with-a-asyncio-coroutines-2/</link>
        <guid isPermaLink="true">http://localhost:4000/Diary/posts/a-web-crawer-with-a-asyncio-coroutines-2/</guid>
        
        <category>crawer</category>
        
        
        <category>posts</category>
        
      </item>
    
      <item>
        <title>用异步协程写一个爬虫 (1)</title>
        <description>&lt;p&gt;本文译自： &lt;a href=&quot;http://www.aosabook.org/en/500L/a-web-crawler-with-asyncio-coroutines.html&quot;&gt;A Web Crawler With asyncio Coroutines&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;由于本文篇幅很长, 在阅读本文之前不妨看一下 &lt;a href=&quot;https://www.zhihu.com/question/20899988&quot;&gt;如何入门 Python 爬虫&lt;/a&gt; 了解爬虫的基本概念, 有时间再继续阅读.&lt;/p&gt;

&lt;h3 id=&quot;introduction&quot;&gt;Introduction&lt;/h3&gt;

&lt;p&gt;传统的计算机科学总是将关注点放在研究更加有效率的算法上， 放在如何才能够更快地完成计算上。 但是实际上，对于很多网络程序， 它们的大部分时间并非花在计算， 而是耗费在维持低速连接或是一些很少发生的事件上。 这类程序面临的是一个非常不同以往的挑战： 高效地等待海量的网络事件。 当前应对该挑战的方法是使用异步 I/O (asynchronous I/O), “async” .&lt;/p&gt;

&lt;p&gt;本文将会展示一个简单的爬虫。 这个爬虫仅仅是一个异步应用的原型， 因为尽管它等待很多响应，但实际并没有做多少计算。 爬虫一次能够获取的页面越多，整个任务完成地就会越快。 如果它对每个请求都消耗一个线程 (thread), 那么当并发请求数增加时， 在耗尽 socket 资源之前, 它就将耗尽内存或是其他线程相关的资源。 通过使用异步 I/O 可以避免对线程的需求。&lt;/p&gt;

&lt;p&gt;我们将会以三个阶段来解读案例：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;第一阶段， 我们展示了一个异步的事件循环 (event loop)，大致勾勒了使用带有回调 (callback) 事件循环的爬虫框架。 虽然十分有效， 但是要想对它进行扩展来处理更复杂的问题, 将会导致产生很多不可控制的意大利面式代码 (译者注: 意大利面式代码, spagjetti code, 大意指代码的控制结构复杂、混乱而难以理解)。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;第二阶段， 我们将会展示兼具效率与扩展性的 Python coroutine (协程) 。 我们还将通过使用 Python 的 generator(生成器) 函数， 实现一个简单的 coroutine。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;第三阶段， 我们将会使用有着完整协程特性的 Python 标准库 “asyncio” &lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;,  同时使用一个异步队列进行协调, 实现一个异步的爬虫。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;the-task&quot;&gt;The Task&lt;/h3&gt;

&lt;p&gt;一个爬虫会查找并下载一个网站上的所有页面， 并且可能还会存储或者给它们加上索引。 从根 URL (root URL) 开始， 它会爬取每一个页面，并且对其进行解析得到 “尚未见过” 页面的链接，然后将这些链接加入到待爬取的队列中。 只有当爬虫获取到的页面上的所有链接都已经 “见过”， 或者等待爬取的队列为空， 爬虫才会停止工作。&lt;/p&gt;

&lt;p&gt;我们可以通过并发地下载多个页面来加快整个爬虫的进程。 当爬虫发现新的链接时， 它同时通过独立的 socket 开始获取新的页面. 当新页面到达时， 它会解析响应并将新的链接添加到队列中。 当存在大量并发时，性能会有所下降，因此有必要压缩返回信息, 同时我们也会限制并发请求数，并且直到一些正在进行中的请求完成后, 才继续开始待爬取队列中的剩余链接。&lt;/p&gt;

&lt;h3 id=&quot;the-traditional-approach&quot;&gt;The Traditional Approach&lt;/h3&gt;

&lt;p&gt;如何才能够让爬虫并发工作？ 传统上， 我们会创建一个线程池， 每个线程将会负责通过一个 socket 每次下载一个页面. 比如， 从 &lt;code class=&quot;highlighter-rouge&quot;&gt;xkcd.com&lt;/code&gt; 下载一个页面：&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;fetch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;sock&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;sock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;connect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'xkcd.com'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;80&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;request&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'GET {} HTTP/1.0&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\r\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;Host: xkcd.com&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\r\n\r\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;format&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;sock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;send&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;encode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'ascii'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;response&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;''&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;chunk&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;recv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4096&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;chunk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;response&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;chunk&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;chunk&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;recv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4096&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;c&quot;&gt;#  Page is now downloaded&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;links&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parse_links&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;response&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;links&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;默认情况下， socket 操作是 &lt;em&gt;阻塞式(blocking)&lt;/em&gt; 的： 当线程调用像 &lt;code class=&quot;highlighter-rouge&quot;&gt;connect&lt;/code&gt; 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;recv&lt;/code&gt; 这样的方法时， 它会暂停进入等待状态直至操作完成 &lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;。 因此, 如果想要一次性下载多个页面， 我们就需要很多线程。 一个成熟的应用, 通常会通过保持线程池中的闲置线程来分摊线程创建的成本, 然后在后续的任务中对这些线程进行检查并进行重用； 对于连接池的 socket 也是同样的处理。&lt;/p&gt;

&lt;p&gt;然而， 使用线程有着很高的成本，并且操作系统会给线程强加很多限制，用户，机器都会受到影响。 在 Jesse (原作者)的系统上， 一个 Python 线程将会花费 50k 的内存，而且如果创建非常多的线程时会导致失败。 把规模继续扩大, 如果使用并发的 socket 执行成百上千的同步操作， 那么在 socket 资源耗尽之前, 我们就会用光线程资源。 单个线程的消耗, 或者系统对于线程的限制, 是这其中的瓶颈。&lt;/p&gt;

&lt;p&gt;在 Dan Kegel 一篇很有影响力的文章 “The C10K problem &lt;sup id=&quot;fnref:3&quot;&gt;&lt;a href=&quot;#fn:3&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;” 中， 他大致描述了 I/O 并发中多线程的一些局限。 开头是这么说的：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;难道你不认为如今的网络服务器应该有能力同时应付成千上万的客户端请求吗？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Kegel 在 1999 年创造了 “C10K” 这个词。 虽然上万的连接现在听起来并不少，但其实只是问题的规模发生了改变， 其问题类型却并未改变。 在那个时候， 对于 C10K 的每个连接采用一个线程是十分不实用的.  的确，仅仅通过使用线程, 我们写的这个玩具级别的爬虫也可以工作。 但是对于有着成千上万连接的大规模应用来说，它的天花板依旧存在： 大多数系统虽然仍然能够创建 socket, 但是却已经耗尽了 thread. 那么如何解决这个问题呢？&lt;/p&gt;

&lt;h3 id=&quot;async&quot;&gt;Async&lt;/h3&gt;

&lt;p&gt;异步的 I/O 框架在一个单一 thread 上使用 &lt;em&gt;non-blocking (非阻塞)&lt;/em&gt;  的 socket 完成并发操作。 在我们的异步爬虫中，在开始连接到服务器之前，我们将 socket 设置为非阻塞式的:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;n&quot;&gt;sock&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;sock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;setblocking&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;False&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;try&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;sock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;connect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'xkcd.com'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;80&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;except&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BlockingIOError&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;pass&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;恼人的是，即便当一个非阻塞的 socket 正常工作的时候， 它也会从 &lt;code class=&quot;highlighter-rouge&quot;&gt;connect&lt;/code&gt; 中抛出一个异常. 这个异常复制了底层 C 函数一个令人心烦的行为 – 它会发送 &lt;code class=&quot;highlighter-rouge&quot;&gt;errno&lt;/code&gt; 到 &lt;code class=&quot;highlighter-rouge&quot;&gt;EINPROGRESS&lt;/code&gt; 来告诉你已经开始工作了。&lt;/p&gt;

&lt;p&gt;爬虫需要有一个途径来知道连接何时已经建立， 以便于它能够发起 HTTP 请求。那么, 我们可以在一个简单紧凑的循环中不停地尝试:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;n&quot;&gt;request&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'GET {} HTTP/1.0&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\r\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;Host: xkcd.com&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\r\n\r\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;format&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;encoded&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;encode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'ascii'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;sock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;send&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;encoded&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;# Done&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;except&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;OSError&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;pass&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'sent'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;但是， 这个方法不仅浪费电能，而且无法在 &lt;em&gt;多个&lt;/em&gt; socket 上高效地等待事件。 在以前， BSD unix 对这个问题的解决方案是使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;select&lt;/code&gt;, 这是一个在一个或多个 socket 上等待事件的 C 函数。 由于今天对于海量连接的网络应用的要求，已经出现了像 &lt;code class=&quot;highlighter-rouge&quot;&gt;poll&lt;/code&gt; 这样的替代品，以及随后的 BSD 上的 &lt;code class=&quot;highlighter-rouge&quot;&gt;kqueue&lt;/code&gt;， Linux 上的 &lt;code class=&quot;highlighter-rouge&quot;&gt;epoll&lt;/code&gt;. 这些 API 与 &lt;code class=&quot;highlighter-rouge&quot;&gt;select&lt;/code&gt; 相类似，但是在面对大量连接时表现十分优异。&lt;/p&gt;

&lt;p&gt;Python 3.4 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;DefaultSelector&lt;/code&gt;,  会使用了当前系统上已有最好的类 &lt;code class=&quot;highlighter-rouge&quot;&gt;select&lt;/code&gt; 函数。 为了注册网络 I/O 的通知， 我们创建一个非阻塞的 socket 并使用默认的 selector 对其进行注册:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;selectors&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DefaultSelector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EVENT_WRITE&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;selector&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DefaultSelector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;sock&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;sock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;setblocking&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;False&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;try&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;sock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;connect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'xkcd.com'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;80&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;except&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BlockingIOError&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;pass&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;connected&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;selector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unregister&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fileno&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'connected'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;selector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;register&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fileno&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EVENT_WRITE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;connected&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们忽略了上面无关紧要的错误, 并调用了 &lt;code class=&quot;highlighter-rouge&quot;&gt;selector.register&lt;/code&gt;,  它传入的参数有 socket 的文件描述符， 一个表示我们正在等待事件类型的常数。 我们还传入一个 Python 函数 &lt;code class=&quot;highlighter-rouge&quot;&gt;connected&lt;/code&gt;, 当事件发生时, &lt;code class=&quot;highlighter-rouge&quot;&gt;connected&lt;/code&gt; 就会运行。这样的函数通常叫做 &lt;em&gt;回调 (callback)&lt;/em&gt; 函数.&lt;/p&gt;

&lt;p&gt;在一个循环中，当我们接收到 I/O 通知时就会对其进行处理:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;loop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;events&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;selector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;select&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;event_key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;event_mask&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;events&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;callback&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;event_key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;callback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;connect&lt;/code&gt; 回调被存储为 &lt;code class=&quot;highlighter-rouge&quot;&gt;event_key.data&lt;/code&gt;, 一旦非阻塞 socket 连接完成, 我们就会进行检索和执行。&lt;/p&gt;

&lt;p&gt;并不像上面的快速循环， 这里对 &lt;code class=&quot;highlighter-rouge&quot;&gt;select&lt;/code&gt; 的调用会暂停等待下一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;I/O&lt;/code&gt; 事件。 尚未完成的操作将会被挂起, 直至事件循环的未来 tick.&lt;/p&gt;

&lt;p&gt;至此, 我们已经阐明了哪些内容？ 我们展示了如何开始一个操作，当操作准备完成后如何执行一个回调。 基于我们已经展示的特性 – 非阻塞的 socket 和事件循环, 构建一个异步 &lt;em&gt;框架 (framework)&lt;/em&gt; 在单一线程上执行并发操作。&lt;/p&gt;

&lt;p&gt;到目前为止, 我们已经完成了 “并发 (concurrency)” 这一目标，但还不是传统意义上的 “并行 (parallelism)”. 也就是说，我们构建一个能够完成 I/O 重叠的小型系统。 当其他操作正在进行时，它能够开始一个新的操作。 实际上，它并没有利用多核并行地执行计算。不过， 这个系统是针对 I/O 限制问题而设计的，而并非 CPU 限制 &lt;sup id=&quot;fnref:4&quot;&gt;&lt;a href=&quot;#fn:4&quot; class=&quot;footnote&quot;&gt;4&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;p&gt;所以我们的时间循环在并发 I/O 上是十分有效的， 因为它不会对每一个连接都耗尽线程资源。 不过在我们继续往下之前，需要纠正有一个常见但十分重要的误解: 异步比多线程要 &lt;em&gt;快&lt;/em&gt; 。 通常并非如此，实际上，在 Python 里，像我们这样的一个事件循环, 通常会稍慢于服务于一小部分非常活跃的连接的多线程。 在一个没有全局解释器锁 (GIL) 的运行态中，线程在这样的一个负载上将会表现得更好。 异步 I/O 所适用的是那些有很多不常发生的事件, 以及低速与休眠连接的应用 &lt;sup id=&quot;fnref:5&quot;&gt;&lt;a href=&quot;#fn:5&quot; class=&quot;footnote&quot;&gt;5&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;h3 id=&quot;programming-with-callbacks&quot;&gt;Programming With Callbacks&lt;/h3&gt;

&lt;p&gt;到这里, 我们已经完成了一个短小的异步框架， 那么如何才能构建一个爬虫？ 要知道即使是一个简单的 URL 获取器 (URL-fetcher), 可能都不是那么简单。&lt;/p&gt;

&lt;p&gt;我们以一个还没有抓取和已抓取的 URL 的全局集合开始，&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;n&quot;&gt;urls_todo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'/'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;seen_urls&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'/'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;')&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;

&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;集合 &lt;code class=&quot;highlighter-rouge&quot;&gt;seen_urls&lt;/code&gt; 等于 &lt;code class=&quot;highlighter-rouge&quot;&gt;urls_todo&lt;/code&gt; 加上未完成的 URL, 两个集合同被初始化为根 URL “/” .&lt;/p&gt;

&lt;p&gt;抓取一个页面会需要一系列的回调。 当连接建立时， &lt;code class=&quot;highlighter-rouge&quot;&gt;connected&lt;/code&gt; 回调就会启动, 并向服务器发送一个 GET 请求. 但是它必须等待回应，所以它注册了另一个回调。 如果当回调启动后，它还没有读取到完整的信息，那么它会再次注册，如此往复。&lt;/p&gt;

&lt;p&gt;现在, 让我们将这些回调组合到一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;Fetcher&lt;/code&gt; 对象中。 它需要一个 URL, 一个 socket 对象，还有一个能够存储响应消息的地方。&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Fetcher&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;response&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;''&lt;/span&gt;   &lt;span class=&quot;c&quot;&gt;# Empty array of bytes.&lt;/span&gt;
        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;url&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;
        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sock&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;Fetcher.fetch&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;c&quot;&gt;# Method on Fetcher class.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;fetch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sock&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;setblocking&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;False&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;connect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'xkcd.com'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;80&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;except&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BlockingIOError&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;pass&lt;/span&gt;

    &lt;span class=&quot;c&quot;&gt;# Register next callback&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;selector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;register&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fileno&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt;
                      &lt;span class=&quot;n&quot;&gt;EVENT_WRITE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                      &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;connected&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;fetch&lt;/code&gt; 方法首先开始连接一个 socket. 但是注意, 在连接建立之前, 该方法已经返回了。 它必须返回时间循环的控制以等待连接。 要想理解为什么， 想想我们整个应用的结构：&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;c&quot;&gt;# Begin fetching http://xkcd.com/353/&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;fetcher&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Fetcher&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'/353/'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;fetcher&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fetch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;events&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;selector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;select&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;event_key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;event_mask&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;events&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;callback&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;event_key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;callback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;event_key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;event_mask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;当它调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;select&lt;/code&gt; 时， 所有的事件通知都会在事件循环中进行处理。因此 &lt;code class=&quot;highlighter-rouge&quot;&gt;fetch&lt;/code&gt; 必须能够控制事件循环，以便于程序知道何时 socket 已经连接. 这样循环才会运行 &lt;code class=&quot;highlighter-rouge&quot;&gt;connected&lt;/code&gt; 回调，也就是上面 &lt;code class=&quot;highlighter-rouge&quot;&gt;fetch&lt;/code&gt; 末尾注册的那个函数。&lt;/p&gt;

&lt;p&gt;这里是 &lt;code class=&quot;highlighter-rouge&quot;&gt;connected&lt;/code&gt; 的实现:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;c&quot;&gt;# Method on Fetcher class.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;connected&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'connected!'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;selector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unregister&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;request&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'GET {} HTTP/1.0&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\r\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;Host: xkcd.com&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\r\n\r\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;format&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;send&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;encode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'ascii'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;

    &lt;span class=&quot;c&quot;&gt;# Register the next callback.&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;selector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;register&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                      &lt;span class=&quot;n&quot;&gt;EVENT_READ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                      &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;read_response&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;方法发送一个 GET 请求。在实际使用中, 一个应用将会检查 &lt;code class=&quot;highlighter-rouge&quot;&gt;send&lt;/code&gt; 的返回值, 以免整个消息并未被一次性发送出去。不过由于我们的请求很小，应用也并不复杂。 它可以不用考虑太多, 直接调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;send&lt;/code&gt; ， 然后等待一个响应。当然了，它必须注册另外的一个回调, 并且重新将控制权交还给事件循环。下一个和最后的回调， &lt;code class=&quot;highlighter-rouge&quot;&gt;read_response&lt;/code&gt;, 处理服务器的回复：&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;c&quot;&gt;# Method on Fetcher class.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;read_response&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;global&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stopped&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;chunk&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;recv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4096&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;# 4k chunk size.&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;chunk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;response&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;chunk&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;selector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unregister&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# Done reading.&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;links&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parse_links&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

        &lt;span class=&quot;c&quot;&gt;# Python set-logic:&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;link&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;links&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;difference&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;seen_urls&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;urls_todo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;link&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;Fetcher&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;link&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fetch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# &amp;lt;- New Fetcher&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;seen_urls&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;update&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;links&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;urls_todo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;urls_todo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;stopped&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;每当选择器 (selector) 看到 socket 是 “可读的”, 就会执行回调。这里的 “可读”，可能表示：socket 有数据或者被关闭。&lt;/p&gt;

&lt;p&gt;回调会从 socket 请求 4 kb 的数据。如果不足, &lt;code class=&quot;highlighter-rouge&quot;&gt;chunk&lt;/code&gt; 将会有多少取多少, 包含能够获取的所有数据。如果多于 4 kb, &lt;code class=&quot;highlighter-rouge&quot;&gt;chunk&lt;/code&gt; 将会填满 4 kb, 并且 socket 会保持可读的状态，因此事件循环能够在下一个 tick 再次运行这个回调。 当响应完毕， 服务器会关闭 socket，此时 &lt;code class=&quot;highlighter-rouge&quot;&gt;chunk&lt;/code&gt; 为空。&lt;/p&gt;

&lt;p&gt;尚未出现的 &lt;code class=&quot;highlighter-rouge&quot;&gt;parse_links&lt;/code&gt; 方法返回一些 URL 的集合。 对于每个新的 URL, 我们启动一个新的 fetcher, 没有并发限制。 注意带有回调的异步程序有一个很好的特性: 我们不需要应对共享数据发生变化的信号量， 比如我们在 &lt;code class=&quot;highlighter-rouge&quot;&gt;seen_urls&lt;/code&gt; 中添加链接。 因为并没有抢占式的多任务，所以在代码中的任一点都不会被中断。&lt;/p&gt;

&lt;p&gt;我们添加了一个全局的 &lt;code class=&quot;highlighter-rouge&quot;&gt;stopped&lt;/code&gt; 变量，并通过它来控制循环:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;n&quot;&gt;stopped&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;False&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;loop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stopped&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;events&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;selector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;select&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;event_key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;event_mask&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;events&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;callback&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;event_key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;callback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;一旦所有的页面被下载完毕， fetcher 停止全局的事件循环, 然后程序退出。&lt;/p&gt;

&lt;p&gt;这个示例使得 async 问题十分显然: spaghetti code. 我们需要一些途径来传递一些计算和 I/O 操作，还需要安排多个这样的一系列操作来并发运行。 但是如果没有线程，这一系列的操作就无法被整合到一个单一的函数中: 无论何时一个函数开始一个 I/O 操作，它会显式地保存在未来需要用到的任何状态。 你需要负责考虑完成这样的状态保存代码。&lt;/p&gt;

&lt;p&gt;让我们来简单解释一下。传统上使用一个阻塞式的 socket, 我们可以通过一个线程十分简单地获取一个 URL:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;c&quot;&gt;# Blocking version.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;fetch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;sock&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;sock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;connect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'xkcd.com'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;80&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;request&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'GET {} HTTP/1.0&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\r\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;Host: xkcd.com&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\r\n\r\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;format&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;sock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;send&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;encode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'ascii'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;response&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;''&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;chunk&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;recv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4096&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;chunk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;response&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;chunk&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;chunk&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;recv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4096&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;c&quot;&gt;# Page is now downloaded.&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;links&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parse_links&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;response&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;links&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在两个 socket 操作之间， 这个函数会记住什么状态呢？ 它有 socket, 一个 URL， 和不断增加的 &lt;code class=&quot;highlighter-rouge&quot;&gt;response&lt;/code&gt; . 运行于一个线程上的函数, 利用了编程语言的基本特性将这个临时状态存储在本地变量中，在它的栈上。 这个函数也有一个 “延续” - 这是说，在 I/O 完成后预期执行的代码。通过存储线程的执行指针，运行期会记住这个 “延续”。 你不必考虑存储这些本地变量和 I/O 完成后的 “延续”。 这是语言所内置的功能。&lt;/p&gt;

&lt;p&gt;不过对于一个基于回调的异步框架而言，这些语言特性并没有什么帮助。 当等待 I/O 时，一个函数必须显式地保存它的状态，因为在 I/O 完成以前函数就会返回并且失去它的栈帧。 为了代替本地变量， 我们基于回调的示例将 &lt;code class=&quot;highlighter-rouge&quot;&gt;sock&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;response&lt;/code&gt; 保存为 &lt;code class=&quot;highlighter-rouge&quot;&gt;self&lt;/code&gt; 的属性， Fetcher 的实例。 为了取代指令指针，它通过注册回调 &lt;code class=&quot;highlighter-rouge&quot;&gt;connected&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;read_response&lt;/code&gt; 存贮其延续。 当应用的特性不断增加时， 我们手动保存回调间状态的复杂性也会随之增加。这样繁琐的记账式代码会使程序员十分头痛。&lt;/p&gt;

&lt;p&gt;更糟糕的是，如果一系列中安排中, 下一个回调它抛出异常怎么办？ 假如我们写的 &lt;code class=&quot;highlighter-rouge&quot;&gt;parse_links&lt;/code&gt; 并不完美，当解析某些 HTML 时它抛出了一个异常：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Traceback (most recent call last):
  File &quot;loop-with-callbacks.py&quot;, line 111, in &amp;lt;module&amp;gt;
    loop()
  File &quot;loop-with-callbacks.py&quot;, line 106, in loop
    callback(event_key, event_mask)
  File &quot;loop-with-callbacks.py&quot;, line 51, in read_response
    links = self.parse_links()
  File &quot;loop-with-callbacks.py&quot;, line 67, in parse_links
    raise Exception('parse error')
Exception: parse error
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;追踪栈仅指示出事件循环正在执行一个回调。 我们不知道到底什么导致了这个错误。 在链的两端都出现了问题： 我们忘了去向何方和来自哪里。 这种背景信息的丢失叫做 “stack ripping”, 在很多时候它都会使调试人员更加糊涂。 stack ripping 也阻止我们对回调设置一个异常捕获, &lt;code class=&quot;highlighter-rouge&quot;&gt;try / except&lt;/code&gt; 块会将一个函数调用及其后续包装起来。&lt;/p&gt;

&lt;p&gt;所以，即使除了长久以来有关多线程与异步在效率上的争论，还有另一个问题 – 哪一个更加容易出错：如果在同步线程的时候犯了错误，那么线程对数据会十分敏感。但是由于 stack ripping 回调又十分难于调试。&lt;/p&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;Guido introduced the standard asyncio library, called “Tulip” then, at &lt;a href=&quot;http://pyvideo.org/video/1667/keynote&quot;&gt;PyCon 2013&lt;/a&gt;. &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot;&gt;
      &lt;p&gt;Even calls to send can block, if the recipient is slow to acknowledge outstanding messages and the system’s buffer of outgoing data is full. &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:3&quot;&gt;
      &lt;p&gt;http://www.kegel.com/c10k.html &lt;a href=&quot;#fnref:3&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:4&quot;&gt;
      &lt;p&gt;Python’s global interpreter lock prohibits running Python code in parallel in one process anyway. Parallelizing CPU-bound algorithms in Python requires multiple processes, or writing the parallel portions of the code in C. But that is a topic for another day. &lt;a href=&quot;#fnref:4&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:5&quot;&gt;
      &lt;p&gt;Jesse listed indications and contraindications for using async in “What Is Async, How Does It Work, And When Should I Use It?”:. Mike Bayer compared the throughput of asyncio and multithreading for different workloads in “Asynchronous Python and Databases”: &lt;a href=&quot;#fnref:5&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
        <pubDate>Tue, 23 May 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/Diary/posts/a-web-crawer-with-a-asyncio-coroutines-1/</link>
        <guid isPermaLink="true">http://localhost:4000/Diary/posts/a-web-crawer-with-a-asyncio-coroutines-1/</guid>
        
        <category>crawer</category>
        
        
        <category>posts</category>
        
      </item>
    
  </channel>
</rss>
