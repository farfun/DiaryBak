<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title> 用异步协程写一个爬虫 (2)</title><meta name="description" content="本文译自： A Web Crawler With asyncio Coroutines。"><link rel="canonical" href="http://localhost:4000/blog-cn/posts/a-web-crawer-with-a-asyncio-coroutines-2/"><link rel="alternate" type="application/rss+xml" title="Liu-Cheng Xu" href="http://localhost:4000/blog-cn/feed.xml"><link href='https://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700|Roboto+Condensed:700&subset=latin' rel='stylesheet' type='text/css'><link rel="stylesheet" href="http://localhost:4000/blog-cn/assets/css/main.css"><link rel="shortcut icon" href="/assets/images/x.gif"><meta property="og:url" content="http://localhost:4000/posts/a-web-crawer-with-a-asyncio-coroutines-2/"><meta property="og:type" content="website"><meta property="og:title" content="用异步协程写一个爬虫 (2)"><meta property="og:description" content=""><meta property="og:site_name" content="Liu-Cheng Xu"><meta name="twitter:card" content="summary"><meta name="twitter:url" content="http://localhost:4000/posts/a-web-crawer-with-a-asyncio-coroutines-2/"><meta name="twitter:title" content="用异步协程写一个爬虫 (2)"><meta name="twitter:description" content=""><meta property="og:image" content="http://localhost:4000/assets/images/bg.svg"><meta name="twitter:image" content="http://localhost:4000/assets/images/bg.svg"> <script type="text/x-mathjax-config"> MathJax.Hub.Config({ tex2jax: { inlineMath: [ ['$','$'], ["\\(","\\)"] ], displayMath: [ ['$$','$$'], ["\\[","\\]"] ], processEscapes: true, skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'], }, TeX: { equationNumbers: { autoNumber: "AMS" } } }); MathJax.Hub.Queue(function() { var all = MathJax.Hub.getAllJax(), i; for(i=0; i < all.length; i += 1) { all[i].SourceElement().parentNode.className += ' has-jax'; } }); </script> <script type="text/javascript" async src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script> <script type="text/javascript" charset="utf-8"> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments) },i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','//www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-73260325-3', 'auto'); ga('send', 'pageview'); </script><body><div id="shadow"></div><header class="main-header content-wrapper"> <input type="checkbox" id="menu-checkbox" /><nav class="center-wrapper nav-main"> <a class="blog-logo" href="/blog-cn/">Liu-Cheng Xu</a> <a href="https://github.com/liuchengxu">GitHub</a> <a href="/blog-cn/about/">About</a> <a href="/blog-cn/feed.xml">RSS</a> <label for="menu-checkbox" class="toggle-button" data-open="☰" data-close="☰" onclick></label></nav></header><main class="content-wrapper"><article class="post"><h1 class="post-title">用异步协程写一个爬虫 (2)</h1><p class="post-meta"> <time datetime="2017-06-10">10-06-2017</time><div class="post-content"><p>本文译自： <a href="http://www.aosabook.org/en/500L/a-web-crawler-with-asyncio-coroutines.html">A Web Crawler With asyncio Coroutines</a>。<p>在上一篇的最后, 我们提到了多线程与异步的一些问题, 下面来介绍一下 Python 的协程(coroutines), 它兼具了多线程与异步的一些优点.<h3 id="coroutines">Coroutines</h3><p>其实是存在 “美貌与智慧” 兼得的方法的。 将回调的有效性与多线程程序的经典好处结合到一起的异步代码是很有可能的。其方法就是使用叫做 “协程(coroutines)” 的模式。使用 Python3.4 中的标准 asyncio 库，和一个叫做 “aiohttp” 的 package, 在一个协程中获取一个 URL 非常直观：<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="nd">@asyncio.coroutines</span>
<span class="k">def</span> <span class="nf">fetch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">url</span><span class="p">):</span>
    <span class="n">response</span> <span class="o">=</span> <span class="k">yield</span> <span class="k">from</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
    <span class="n">body</span> <span class="o">=</span> <span class="k">yield</span> <span class="k">from</span> <span class="n">response</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>

</code></pre></div></div><p>它同时还具有伸缩性 (scalable)。 与每个线程 50k 的内存消耗与操作系统对于线程的严格限制相比，一个 Python 的协程仅仅消耗 3k . Python 可以轻松地启动成百上千的协程。<p>协程的概念其实很简单: 它是一个能够被暂停和重新启动的子程序。尽管线程被操作系统抢占式的多任务安排，协程的多任务是协作式的：它们选择合适暂停，然后下一次运行哪一个协程。<p>协程有许多实现，即使是在 Python 中也有好几个实现。在 Python3.4 的标准 “asyncio” 库中， 协程基于生成器，使用了 “yield from” 声明. 自从 Python 3.5 , 线程已经成为语言的一个天然特性。不过，理解在 Python 3.4 中首先实现的协程，使用预先存在的语言功能，是利用 Python 3.5 天然协程的基础。<p>为了解释 Python 3.4 中基于生成器的协程，我们将会阐述生成器是什么以及在 asyncio 它们是如何用作协程。相信你跟我们乐于书写这部分一样乐于阅读. 一旦解释完基于生成器的协程，我们将会在我们的异步网络爬虫中使用它们。<h3 id="how-python-generators-work">How Python Generators Work</h3><p>在理解 Python 的生成器之前，你必须要理解普通的 Python 函数是如何工作的。 通常来说，当一个Python 函数调用一个 subroutine 时，这个 subroutine 会保留控制直到返回或是抛出一个异常。然后控制返回给调用者：<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
<span class="o">...</span>     <span class="n">bar</span><span class="p">()</span>
<span class="o">...</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">bar</span><span class="p">():</span>
<span class="o">...</span>     <span class="k">pass</span>
</code></pre></div></div><p>标准的 Python 解释器使用 C 写的。执行一个 Python 函数的 C 函数叫做 <code class="highlighter-rouge">PyEval_EvalFrameEx</code>. 它需要一个 Python stack frame 对象，在 frame 的上下文中对 Python 字节码进行求值。 这里是 <code class="highlighter-rouge">foo</code> 的字节码:<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">dis</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">dis</span><span class="o">.</span><span class="n">dis</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>
  <span class="mi">2</span>           <span class="mi">0</span> <span class="n">LOAD_GLOBAL</span>              <span class="mi">0</span> <span class="p">(</span><span class="n">bar</span><span class="p">)</span>
              <span class="mi">3</span> <span class="n">CALL_FUNCTION</span>            <span class="mi">0</span> <span class="p">(</span><span class="mi">0</span> <span class="n">positional</span><span class="p">,</span> <span class="mi">0</span> <span class="n">keyword</span> <span class="n">pair</span><span class="p">)</span>
              <span class="mi">6</span> <span class="n">POP_TOP</span>
              <span class="mi">7</span> <span class="n">LOAD_CONST</span>               <span class="mi">0</span> <span class="p">(</span><span class="bp">None</span><span class="p">)</span>
             <span class="mi">10</span> <span class="n">RETURN_VALUE</span>
</code></pre></div></div><p><code class="highlighter-rouge">foo</code> 函数将 <code class="highlighter-rouge">bar</code> 加载到栈上然后进行调用，并将其从栈上弹出返回值，将 <code class="highlighter-rouge">None</code> 入栈，返回 <code class="highlighter-rouge">None</code>.<p>当 <code class="highlighter-rouge">PyEval_EvalFrameEx</code> 遇到 <code class="highlighter-rouge">CALL_FUNCTION</code> 字节码，它会调用一个新的 Python stack frame 然后递归: 也就是说，它在新的 frame 下递归地调用 <code class="highlighter-rouge">PyEval_EvalFrameEx</code> , 以此来执行 <code class="highlighter-rouge">bar</code>.<p>非常重要的一点是要知道 Python stack frame 是分配于堆内存上！ Python 解释器是一个普通的 C 程序而已，所以它的的 stack frame 也是正常的 stack frame. 但是它控制的 <em>Python stack</em> frame 在堆上。除了其他惊喜，这还意味着一个 Python stack frame 能够比它的函数调用存活时间更长。 为了交互式地观察这一点，在 <code class="highlighter-rouge">bar</code> 内部保存当前的 frame:<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">inspect</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">frame</span> <span class="o">=</span> <span class="bp">None</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
<span class="o">...</span>     <span class="n">bar</span><span class="p">()</span>
<span class="o">...</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">bar</span><span class="p">():</span>
<span class="o">...</span>     <span class="k">global</span> <span class="n">frame</span>
<span class="o">...</span>     <span class="n">frame</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">currentframe</span><span class="p">()</span>
<span class="o">...</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">foo</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="c"># The frame was executing the code for 'bar'.</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">frame</span><span class="o">.</span><span class="n">f_code</span><span class="o">.</span><span class="n">co_name</span>
<span class="s">'bar'</span>
<span class="o">&gt;&gt;&gt;</span> <span class="c"># Its back pointer refers to the frame for 'foo'.</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">caller_frame</span> <span class="o">=</span> <span class="n">frame</span><span class="o">.</span><span class="n">f_back</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">caller_frame</span><span class="o">.</span><span class="n">f_code</span><span class="o">.</span><span class="n">co_name</span>
<span class="s">'foo'</span>
</code></pre></div></div><p><img src="/blog-cn/assets/images/posts/function-calls.png" alt="function-calls" /><p>现在开始设置 Python 生成器的阶段，它使用了同样的 building block - code objects and stack frames - 效果非凡。<p>这是一个生成器函数:<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">gen_fn</span><span class="p">():</span>
<span class="o">...</span>     <span class="n">result</span> <span class="o">=</span> <span class="k">yield</span> <span class="mi">1</span>
<span class="o">...</span>     <span class="k">print</span><span class="p">(</span><span class="s">'result of yield: {}'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>
<span class="o">...</span>     <span class="n">result2</span> <span class="o">=</span> <span class="k">yield</span> <span class="mi">2</span>
<span class="o">...</span>     <span class="k">print</span><span class="p">(</span><span class="s">'result of 2nd yield: {}'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">result2</span><span class="p">))</span>
<span class="o">...</span>     <span class="k">return</span> <span class="s">'done'</span>
<span class="o">...</span>
</code></pre></div></div><p>当Python把 <code class="highlighter-rouge">gen_fn</code> 编译为字节码，它会看到 <code class="highlighter-rouge">yield</code> 并且知道 <code class="highlighter-rouge">gen_fn</code> 是一个生成器函数，而不是普通函数。那么他就会设置一个标记:<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="c"># The generator flag is bit position 5.</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">generator_bit</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">bool</span><span class="p">(</span><span class="n">gen_fn</span><span class="o">.</span><span class="n">__code__</span><span class="o">.</span><span class="n">co_flags</span> <span class="o">&amp;</span> <span class="n">generator_bit</span><span class="p">)</span>
<span class="bp">True</span>
</code></pre></div></div><p>当你调用一个生成器函数时， Python 看到生成器标志，它并不会真正的运行这个函数，而是创建一个生成器：<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">gen</span> <span class="o">=</span> <span class="n">gen_fn</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">type</span><span class="p">(</span><span class="n">gen</span><span class="p">)</span>
<span class="o">&lt;</span><span class="k">class</span> <span class="err">'</span><span class="nc">generator</span><span class="s">'&gt;</span><span class="err">
</span></code></pre></div></div><p>一个 Python 生成器封装了一个 stack frame 和对某些代码的引用， <code class="highlighter-rouge">gen_fn</code> 的主体:<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">gen</span><span class="o">.</span><span class="n">gi_code</span><span class="o">.</span><span class="n">co_name</span>
<span class="s">'gen_fn'</span>
</code></pre></div></div><p>对 <code class="highlighter-rouge">gen_fn</code> 的调用的所有生成器都指向同样的代码。但是每一个都拥有自己的 stack frame. 这个 stack frame 并不是任何真正的栈，它位于堆内存并且等待被使用:<p><img src="/blog-cn/assets/images/posts/generator.png" alt="function-calls" /><p>frame 有一个 “最近指令 (last instruction)” 指针，它最近执行最多的指令。开始的时候，最近指令指针为 -1， 表示生成器还没有开始：<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">gen</span><span class="o">.</span><span class="n">gi_frame</span><span class="o">.</span><span class="n">f_lasti</span>
<span class="o">-</span><span class="mi">1</span>
</code></pre></div></div><p>当我们调用 <code class="highlighter-rouge">send</code> , 生成器到底它的第一个 <code class="highlighter-rouge">yield</code>, 然后暂停。<code class="highlighter-rouge">send</code> 的返回值为 1， 因此这就是 <code class="highlighter-rouge">gen</code> 传递给 <code class="highlighter-rouge">yield</code> 表达式的值：<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">gen</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
<span class="mi">1</span>
</code></pre></div></div><p>生成器的指令指针现在距离开始 3 个字节码， 编译后的Python 56 个字节:<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">gen</span><span class="o">.</span><span class="n">gi_frame</span><span class="o">.</span><span class="n">f_lasti</span>
<span class="mi">3</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">gen</span><span class="o">.</span><span class="n">gi_code</span><span class="o">.</span><span class="n">co_code</span><span class="p">)</span>
<span class="mi">56</span>
</code></pre></div></div><p>生成器可以在任何时间，从任何函数中重新开始，因为它的 stack frame 实际上并没有在栈上: 它在堆上。它在调用继承上的位置并不是固定的，它也不需要像普通函数那样遵循先进后出的执行顺序。 它是自由的，没有任何限制。<p>我们可以发送 “hello” 给生成器，那么 “hello” 会成为 <code class="highlighter-rouge">yield</code> 表达式的结果， 生成器会一直持续直到它产生 2:<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">gen</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="s">'hello'</span><span class="p">)</span>
<span class="n">result</span> <span class="n">of</span> <span class="k">yield</span><span class="p">:</span> <span class="n">hello</span>
<span class="mi">2</span>
</code></pre></div></div><p>它的 stack frame 现在包含了本地变量 <code class="highlighter-rouge">result</code>:<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">gen</span><span class="o">.</span><span class="n">gi_frame</span><span class="o">.</span><span class="n">f_locals</span>
<span class="p">{</span><span class="s">'result'</span><span class="p">:</span> <span class="s">'hello'</span><span class="p">}</span>
</code></pre></div></div><p>由 <code class="highlighter-rouge">gen_fn</code> 创建的其他生成器将会拥有它们自己独立的 stack frame 和 本地变量。<p>当我们再次调用 <code class="highlighter-rouge">send</code> 时，生成器将会从第二个 <code class="highlighter-rouge">yield</code> 继续，并且最终抛出一个特殊的 <code class="highlighter-rouge">StopIteration</code> 异常:<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">gen</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="s">'goodbye'</span><span class="p">)</span>
<span class="n">result</span> <span class="n">of</span> <span class="mi">2</span><span class="n">nd</span> <span class="k">yield</span><span class="p">:</span> <span class="n">goodbye</span>
<span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
  <span class="n">File</span> <span class="s">"&lt;input&gt;"</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="nb">StopIteration</span><span class="p">:</span> <span class="n">done</span>
</code></pre></div></div><p>这个异常有一个值，这个值就是生成器的返回值: 字符串 <code class="highlighter-rouge">"done"</code> .<h3 id="building-coroutines-with-generators">Building Coroutines With Generators</h3><p>所以一个生成器可以暂停, 通过一个值来重新启动，并且有一个返回值。听起来像是可以基于此来构建一个异步程序模型的一个不错的原型，而不必烦人的回调！ 我们想要构建一个 “协程”: 一个能够与程序中其他协程合作调度的协程。我们的协程将是一个 Python 标准库 “asyncio” 的相应内容的简化版本。在 asyncio 中，我们将会使用生成器，futures, 和 “yield from” 语句。<p>首先我们需要有一个方式来表示一个协程等待的未知的结果。 简化版本:<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Future</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">result</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_callbacks</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">add_done_callback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fn</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_callbacks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_result</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">result</span> <span class="o">=</span> <span class="n">result</span>
        <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_callbacks</span><span class="p">:</span>
            <span class="n">fn</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</code></pre></div></div><p>一个 future 初始为 “pending”. 通过一个队 <code class="highlighter-rouge">set_result</code> <sup id="fnref:9"><a href="#fn:9" class="footnote">1</a></sup> 的调用来 “解决” 。<p>让我们调整 fetcher 来使用 future 和 协程。 写一个带有回调的 <code class="highlighter-rouge">fetch</code>:<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Fetcher</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">fetch</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sock</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sock</span><span class="o">.</span><span class="n">setblocking</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sock</span><span class="o">.</span><span class="n">connect</span><span class="p">((</span><span class="s">'xkcd.com'</span><span class="p">,</span> <span class="mi">80</span><span class="p">))</span>
        <span class="k">except</span> <span class="n">BlockingIOError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="n">selector</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sock</span><span class="o">.</span><span class="n">fileno</span><span class="p">(),</span>
                          <span class="n">EVENT_WRITE</span><span class="p">,</span>
                          <span class="bp">self</span><span class="o">.</span><span class="n">connected</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">connected</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">mask</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">'connected!'</span><span class="p">)</span>
        <span class="c"># And so on....</span>
</code></pre></div></div><p><code class="highlighter-rouge">fetch</code> 以连接一个 socket 开始，然后注册回调， <code class="highlighter-rouge">connected</code>, 当 socket 准备好以后执行。 现在我们尅将这两步组合到一个协程中:<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">def</span> <span class="nf">fetch</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">sock</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">()</span>
        <span class="n">sock</span><span class="o">.</span><span class="n">setblocking</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">sock</span><span class="o">.</span><span class="n">connect</span><span class="p">((</span><span class="s">'xkcd.com'</span><span class="p">,</span> <span class="mi">80</span><span class="p">))</span>
        <span class="k">except</span> <span class="n">BlockingIOError</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="n">f</span> <span class="o">=</span> <span class="n">Future</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">on_connected</span><span class="p">():</span>
            <span class="n">f</span><span class="o">.</span><span class="n">set_result</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>

        <span class="n">selector</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">sock</span><span class="o">.</span><span class="n">fileno</span><span class="p">(),</span>
                          <span class="n">EVENT_WRITE</span><span class="p">,</span>
                          <span class="n">on_connected</span><span class="p">)</span>
        <span class="k">yield</span> <span class="n">f</span>
        <span class="n">selector</span><span class="o">.</span><span class="n">unregister</span><span class="p">(</span><span class="n">sock</span><span class="o">.</span><span class="n">fileno</span><span class="p">())</span>
        <span class="k">print</span><span class="p">(</span><span class="s">'connected!'</span><span class="p">)</span>
</code></pre></div></div><p>现在的 <code class="highlighter-rouge">fetch</code> 是一个生成器函数，而非一个普通函数，因为它包含了一个 <code class="highlighter-rouge">yield</code> 语句。 我们创建一个挂起的 future, 然后生成它来暂停 <code class="highlighter-rouge">fetch</code> 直到 socket 准备好。 内部函数 <code class="highlighter-rouge">on_connected</code> 解析 future.<p>当时当 future 解析的时候，什么来重新启动生成器？我们需要一个协程 “驱动器 (driver)”. 就叫它 “task” 吧.<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Task</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coro</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coro</span> <span class="o">=</span> <span class="n">coro</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">Future</span><span class="p">()</span>
        <span class="n">f</span><span class="o">.</span><span class="n">set_result</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">step</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">future</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">next_future</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coro</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">future</span><span class="o">.</span><span class="n">result</span><span class="p">)</span>
        <span class="k">except</span> <span class="nb">StopIteration</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">next_future</span><span class="o">.</span><span class="n">add_done_callback</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">step</span><span class="p">)</span>

<span class="c"># Begin fetching http://xkcd.com/353/</span>
<span class="n">fetcher</span> <span class="o">=</span> <span class="n">Fetcher</span><span class="p">(</span><span class="s">'/353/'</span><span class="p">)</span>
<span class="n">Task</span><span class="p">(</span><span class="n">fetcher</span><span class="o">.</span><span class="n">fetch</span><span class="p">())</span>

<span class="n">loop</span><span class="p">()</span>
</code></pre></div></div><p>通过发送 <code class="highlighter-rouge">None</code> 给 task 来启动 <code class="highlighter-rouge">fetch</code> 生成器。 然后 <code class="highlighter-rouge">fetch</code> 运行直至它生成一个 future, 同时会被 task 捕获为 <code class="highlighter-rouge">next_future</code> .<h3 id="coordinating-coroutines">Coordinating Coroutines</h3><p>一旦 socket 连接上，我们就发送 HTTP GET 请求并读取服务器的响应。 这些步骤不再需要分散于回调之间; 我们可以将它们组合到同一个生成器函数中:<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">def</span> <span class="nf">fetch</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># ... connection logic from above, then:</span>
        <span class="n">sock</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">request</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s">'ascii'</span><span class="p">))</span>

        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">Future</span><span class="p">()</span>

            <span class="k">def</span> <span class="nf">on_readable</span><span class="p">():</span>
                <span class="n">f</span><span class="o">.</span><span class="n">set_result</span><span class="p">(</span><span class="n">sock</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">4096</span><span class="p">))</span>

            <span class="n">selector</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">sock</span><span class="o">.</span><span class="n">fileno</span><span class="p">(),</span>
                              <span class="n">EVENT_READ</span><span class="p">,</span>
                              <span class="n">on_readable</span><span class="p">)</span>
            <span class="n">chunk</span> <span class="o">=</span> <span class="k">yield</span> <span class="n">f</span>
            <span class="n">selector</span><span class="o">.</span><span class="n">unregister</span><span class="p">(</span><span class="n">sock</span><span class="o">.</span><span class="n">fileno</span><span class="p">())</span>
            <span class="k">if</span> <span class="n">chunk</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">response</span> <span class="o">+=</span> <span class="n">chunk</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c"># Done reading.</span>
                <span class="k">break</span>
</code></pre></div></div><p>这段代码，读了 socket 的全部消息，似乎通常都很有用。 我们如何才能将它从 <code class="highlighter-rouge">fetch</code> 分离并填充到一个协程中? 现在 Python 3 的 <code class="highlighter-rouge">yield from</code> 能够完成这个任务。它允许一个生成器委托另一个生成器.<p>为了理解为何如此，让我们回到一个简单的生成器示例：<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">gen_fn</span><span class="p">():</span>
<span class="o">...</span>     <span class="n">result</span> <span class="o">=</span> <span class="k">yield</span> <span class="mi">1</span>
<span class="o">...</span>     <span class="k">print</span><span class="p">(</span><span class="s">'result of yield: {}'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>
<span class="o">...</span>     <span class="n">result2</span> <span class="o">=</span> <span class="k">yield</span> <span class="mi">2</span>
<span class="o">...</span>     <span class="k">print</span><span class="p">(</span><span class="s">'result of 2nd yield: {}'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">result2</span><span class="p">))</span>
<span class="o">...</span>     <span class="k">return</span> <span class="s">'done'</span>
<span class="o">...</span>
</code></pre></div></div><p>从另一个的生成器中调用这个生成器，使用 <code class="highlighter-rouge">yield from</code> 委托给它:<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="c"># Generator function:</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">caller_fn</span><span class="p">():</span>
<span class="o">...</span>     <span class="n">gen</span> <span class="o">=</span> <span class="n">gen_fn</span><span class="p">()</span>
<span class="o">...</span>     <span class="n">rv</span> <span class="o">=</span> <span class="k">yield</span> <span class="k">from</span> <span class="n">gen</span>
<span class="o">...</span>     <span class="k">print</span><span class="p">(</span><span class="s">'return value of yield-from: {}'</span>
<span class="o">...</span>           <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rv</span><span class="p">))</span>
<span class="o">...</span>
<span class="o">&gt;&gt;&gt;</span> <span class="c"># Make a generator from the</span>
<span class="o">&gt;&gt;&gt;</span> <span class="c"># generator function.</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">caller</span> <span class="o">=</span> <span class="n">caller_fn</span><span class="p">()</span>
</code></pre></div></div><p><code class="highlighter-rouge">caller</code> 生成器表现地就如同 <code class="highlighter-rouge">gen</code>,它所委托的生成器:<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">caller</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
<span class="mi">1</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">caller</span><span class="o">.</span><span class="n">gi_frame</span><span class="o">.</span><span class="n">f_lasti</span>
<span class="mi">15</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">caller</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="s">'hello'</span><span class="p">)</span>
<span class="n">result</span> <span class="n">of</span> <span class="k">yield</span><span class="p">:</span> <span class="n">hello</span>
<span class="mi">2</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">caller</span><span class="o">.</span><span class="n">gi_frame</span><span class="o">.</span><span class="n">f_lasti</span>  <span class="c"># Hasn't advanced.</span>
<span class="mi">15</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">caller</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="s">'goodbye'</span><span class="p">)</span>
<span class="n">result</span> <span class="n">of</span> <span class="mi">2</span><span class="n">nd</span> <span class="k">yield</span><span class="p">:</span> <span class="n">goodbye</span>
<span class="k">return</span> <span class="n">value</span> <span class="n">of</span> <span class="k">yield</span><span class="o">-</span><span class="k">from</span><span class="p">:</span> <span class="n">done</span>
<span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
  <span class="n">File</span> <span class="s">"&lt;input&gt;"</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="nb">StopIteration</span>
</code></pre></div></div><p>当 <code class="highlighter-rouge">caller</code> 生成自 <code class="highlighter-rouge">gen</code>, <code class="highlighter-rouge">caller</code> 并不优先。 注意到它的指令指针停留在 15，<code class="highlighter-rouge">yield from</code> 语句的地方，即使是当内部的生成器 <code class="highlighter-rouge">gen</code> 先于一个 <code class="highlighter-rouge">yield</code> 语句进行到下一个 <sup id="fnref:10"><a href="#fn:10" class="footnote">2</a></sup>。 从我们的视角来看 <code class="highlighter-rouge">caller</code>, 我们无法区分它所产生的值是来自 <code class="highlighter-rouge">caller</code> 还是它所代表的生成器。 从内部的 <code class="highlighter-rouge">gen</code>, 我们无法区分值是发送自 <code class="highlighter-rouge">caller</code> 还是 <code class="highlighter-rouge">caller</code> 外部。 <code class="highlighter-rouge">yield from</code> 语句是一个无摩擦的通道，尽管这些值会流入流出 <code class="highlighter-rouge">gen</code> 直到 <code class="highlighter-rouge">gen</code> 完成。<p>一个协程可以通过 <code class="highlighter-rouge">yield from</code> 将工作委托给一个子协程并接受任务结果。 注意，上面的 <code class="highlighter-rouge">caller</code> 打印出 “return value of yield-from: done” . 当 <code class="highlighter-rouge">gen</code> 完成后， 它的返回值变成了 <code class="highlighter-rouge">caller</code> 里面的 <code class="highlighter-rouge">yield from</code> 语句的返回值:<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">rv</span> <span class="o">=</span> <span class="k">yield</span> <span class="k">from</span> <span class="n">gen</span>
</code></pre></div></div><p>早先，我们批评了基于回调的异步程序的不足之处，最大的一个缺点是 “stack ripping”: 当一个回调抛出异常时，追踪栈通常并没有什么用。 它只是显示出事件循环正在运行回调，却没有指示 <em>为什么</em> 。 那么协程如何呢?<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">gen_fn</span><span class="p">():</span>
<span class="o">...</span>     <span class="k">raise</span> <span class="nb">Exception</span><span class="p">(</span><span class="s">'my error'</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">caller</span> <span class="o">=</span> <span class="n">caller_fn</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">caller</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
<span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
  <span class="n">File</span> <span class="s">"&lt;input&gt;"</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
  <span class="n">File</span> <span class="s">"&lt;input&gt;"</span><span class="p">,</span> <span class="n">line</span> <span class="mi">3</span><span class="p">,</span> <span class="ow">in</span> <span class="n">caller_fn</span>
  <span class="n">File</span> <span class="s">"&lt;input&gt;"</span><span class="p">,</span> <span class="n">line</span> <span class="mi">2</span><span class="p">,</span> <span class="ow">in</span> <span class="n">gen_fn</span>
<span class="nb">Exception</span><span class="p">:</span> <span class="n">my</span> <span class="n">error</span>
</code></pre></div></div><p>这些信息相当有用！追踪栈显示 <code class="highlighter-rouge">caller_fn</code> 委托了 <code class="highlighter-rouge">gen_fn</code> 当它抛出错误的时候。 更有效的是，我们可以将子协程的调用包装在一个异常的 handler 猴子那个，同样适用于正常的子协程:<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">gen_fn</span><span class="p">():</span>
<span class="o">...</span>     <span class="k">yield</span> <span class="mi">1</span>
<span class="o">...</span>     <span class="k">raise</span> <span class="nb">Exception</span><span class="p">(</span><span class="s">'uh oh'</span><span class="p">)</span>
<span class="o">...</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">caller_fn</span><span class="p">():</span>
<span class="o">...</span>     <span class="k">try</span><span class="p">:</span>
<span class="o">...</span>         <span class="k">yield</span> <span class="k">from</span> <span class="n">gen_fn</span><span class="p">()</span>
<span class="o">...</span>     <span class="k">except</span> <span class="nb">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
<span class="o">...</span>         <span class="k">print</span><span class="p">(</span><span class="s">'caught {}'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">exc</span><span class="p">))</span>
<span class="o">...</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">caller</span> <span class="o">=</span> <span class="n">caller_fn</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">caller</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
<span class="mi">1</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">caller</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="s">'hello'</span><span class="p">)</span>
<span class="n">caught</span> <span class="n">uh</span> <span class="n">oh</span>
</code></pre></div></div><p>所以我们使用子协程来分离逻辑就像使用普通的子协程一样。 让我们从 fetcher 中分离一些有用的子协程。 我们写一个 <code class="highlighter-rouge">read</code> 协程来接收一个数据块:<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="n">sock</span><span class="p">):</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">Future</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">on_readable</span><span class="p">():</span>
        <span class="n">f</span><span class="o">.</span><span class="n">set_result</span><span class="p">(</span><span class="n">sock</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">4096</span><span class="p">))</span>

    <span class="n">selector</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">sock</span><span class="o">.</span><span class="n">fileno</span><span class="p">(),</span> <span class="n">EVENT_READ</span><span class="p">,</span> <span class="n">on_readable</span><span class="p">)</span>
    <span class="n">chunk</span> <span class="o">=</span> <span class="k">yield</span> <span class="n">f</span>  <span class="c"># Read one chunk.</span>
    <span class="n">selector</span><span class="o">.</span><span class="n">unregister</span><span class="p">(</span><span class="n">sock</span><span class="o">.</span><span class="n">fileno</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">chunk</span>
</code></pre></div></div><p>基于 <code class="highlighter-rouge">read</code> 我们使用了 <code class="highlighter-rouge">read_all</code> 协程来获取一个完整的消息:<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">read_all</span><span class="p">(</span><span class="n">sock</span><span class="p">):</span>
    <span class="n">response</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c"># Read whole response.</span>
    <span class="n">chunk</span> <span class="o">=</span> <span class="k">yield</span> <span class="k">from</span> <span class="n">read</span><span class="p">(</span><span class="n">sock</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">chunk</span><span class="p">:</span>
        <span class="n">response</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
        <span class="n">chunk</span> <span class="o">=</span> <span class="k">yield</span> <span class="k">from</span> <span class="n">read</span><span class="p">(</span><span class="n">sock</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">b</span><span class="s">''</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">response</span><span class="p">)</span>
</code></pre></div></div><p>如果你仔细看的话，<code class="highlighter-rouge">yield from</code> 语句不见了，它们看起来就像是执行阻塞时 I/O 的传统程序。 但是实际上，<code class="highlighter-rouge">read</code> 和 <code class="highlighter-rouge">read_all</code> 都是协程。 <code class="highlighter-rouge">read</code> 所产生的内容会暂停 <code class="highlighter-rouge">read_all</code> 直到 I/O 完成. 当 <code class="highlighter-rouge">read_all</code> 暂停后，asyncio 的事件循环会做其他事情和等到其他的 I/O 事件; 一旦它的事件准备好了，<code class="highlighter-rouge">read_all</code> 就会以下一个循环 tick 的 <code class="highlighter-rouge">read</code> 的结果重新开始。<p>在栈底, <code class="highlighter-rouge">fetch</code> 调用 <code class="highlighter-rouge">read_all</code>:<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Fetcher</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">fetch</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
         <span class="c"># ... connection logic from above, then:</span>
        <span class="n">sock</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">request</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s">'ascii'</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">response</span> <span class="o">=</span> <span class="k">yield</span> <span class="k">from</span> <span class="n">read_all</span><span class="p">(</span><span class="n">sock</span><span class="p">)</span>
</code></pre></div></div><p>出乎意料地，Task 类并不需要有所改变。它会像之前一样驱动外部的 <code class="highlighter-rouge">fetch</code> 协程:<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Task</span><span class="p">(</span><span class="n">fetcher</span><span class="o">.</span><span class="n">fetch</span><span class="p">())</span>
<span class="n">loop</span><span class="p">()</span>
</code></pre></div></div><p>当 <code class="highlighter-rouge">read</code> 生成一个 future, task 通过 <code class="highlighter-rouge">yield from</code> 语句的通道接收 future, 更准确地说，就想好事 future 直接产生自 <code class="highlighter-rouge">fetch</code>. 当循环解析一个 future, task 将它的结果发送给 <code class="highlighter-rouge">fetch</code>, 并且值被 <code class="highlighter-rouge">read</code> 所接收, 跟 task 直接驱动 <code class="highlighter-rouge">read</code> 一样:<p><img src="/blog-cn/assets/images/posts/yield-from.png" alt="yield-from" /><p>为了完善我们的协程实现， 我们去除一个缺点： 当等待一个 future 时使用 <code class="highlighter-rouge">yield</code>, 但是当它委托给一个子协程时使用 <code class="highlighter-rouge">yield from</code>. 如果无论当一个协程何时暂停，我们都使用 <code class="highlighter-rouge">yield from</code> 就更好了。那么一个协程就不再需要考虑它所等待的是一个什么类型的东西.<p>我们利用了 Python 中生成器与迭代器之间的深层次联系。 对 caller 来说，生成器很高级， 迭代器同样很高级。所以我们通过实现一个特殊的方法来使得 Future 类可迭代:<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c"># Method on Future class.</span>
    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># Tell Task to resume me here.</span>
        <span class="k">yield</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">result</span>
</code></pre></div></div><p>future 的 <code class="highlighter-rouge">__iter__</code> 方法是一个产生 future 自身的协程。 现在我们来替换像这样的代码:<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># f is a Future.</span>
<span class="k">yield</span> <span class="n">f</span>
</code></pre></div></div><p>用这样的来替换:<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># f is a Future.</span>
<span class="k">yield</span> <span class="k">from</span> <span class="n">f</span>
</code></pre></div></div><p>…结果是一样的！ 驱动 Task 从它对 <code class="highlighter-rouge">send</code> 的调用中接收 future, 当 future 被解析后它将新的结果返回给协程。<p>到处使用 <code class="highlighter-rouge">yield from</code> 有什么好处呢? 为什么使用 <code class="highlighter-rouge">yield</code> 等待 future 和使用 <code class="highlighter-rouge">yield from</code> 委托给子协程更好？ 它更好是因为，一个方法可以不影响 caller 而自由地改变它的实现: 它可能是一个普通的方法，返回将会 <em>解析</em> 为一个值的 future , 或者它可能是一个包含了 <code class="highlighter-rouge">yield from</code> 语句的协程，并且 <em>返回</em> 了一个值。 无论是哪种情况，caller 仅需要从方法中 <code class="highlighter-rouge">yeild from</code> 以此来等待结果。<p>至此，我们到了 asyncio 中协程的尾部。 我们仔细了解了生成器的工作机制，大概勾勒了 future 和 task 的实现。 当然了，实际的 asyncio 要比我们勾勒的版本要复杂得多。真正的框架解决了 另附纸 I/O, 公平安排，异常捕获和一些其他丰富的特性。<p>对于 asyncio 的用户而言， 使用协程来写程序要比上面看到的要简单得多。 在上面的代码中，我们从第一个原则起实现了一个协程，里面包括了 callback, task 和 future. 你甚至看到了非阻塞式的 socket 和对于 <code class="highlighter-rouge">select</code> 的调用。 但是当使用 asyncio 来真正构建一个应用时， 上面的代码并不会出现。如我们所望，你可以像下面一样简洁地获取一个 URL:<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
    <span class="nd">@asyncio.coroutine</span>
    <span class="k">def</span> <span class="nf">fetch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">url</span><span class="p">):</span>
        <span class="n">response</span> <span class="o">=</span> <span class="k">yield</span> <span class="k">from</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
        <span class="n">body</span> <span class="o">=</span> <span class="k">yield</span> <span class="k">from</span> <span class="n">response</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>

</code></pre></div></div><p>对于协程的阐述到此告一段落，下面回到一开始的任务: 使用 asyncio 写一个异步爬虫.<div class="footnotes"><ol><li id="fn:9"><p>This future has many deficiencies. For example, once this future is resolved, a coroutine that yields it should resume immediately instead of pausing, but with our code it does not. See asyncio’s Future class for a complete implementation.↩ <a href="#fnref:9" class="reversefootnote">&#8617;</a><li id="fn:10"><p>In fact, this is exactly how “yield from” works in CPython. A function increments its instruction pointer before executing each statement. But after the outer generator executes “yield from”, it subtracts 1 from its instruction pointer to keep itself pinned at the “yield from” statement. Then it yields to its caller. The cycle repeats until the inner generator throws StopIteration, at which point the outer generator finally allows itself to advance to the next instruction.↩ <a href="#fnref:10" class="reversefootnote">&#8617;</a></ol></div><a class="link-to-post" href="/blog-cn/posts/bitcoin-explained-1/"> <span class="link-to-post__next">&#10535; &nbsp;Next post</span> <span class="link-to-post__title">用表情符号解释比特币 (1)</span> </a> <a class="link-to-post" href="/blog-cn/posts/a-web-crawer-with-a-asyncio-coroutines-1/"> <span class="link-to-post__prev">&#10535; &nbsp;Previous post</span> <span class="link-to-post__title">用异步协程写一个爬虫 (1)</span> </a></div></article></main><footer class="blog-footer content-wrapper"><p>&copy; <span class="full-year"></span> Liu-Cheng Xu</footer><script src="/blog-cn/assets/js/scripts.js"></script> <script type="text/javascript" charset="utf-8"> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments) },i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','//www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-73260325-3', 'auto'); ga('send', 'pageview'); </script>
