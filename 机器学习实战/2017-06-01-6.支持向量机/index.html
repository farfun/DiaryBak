<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../../img/favicon.ico">
        <title>6.支持向量机.md - DataLab</title>
        <link href="../../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../../css/font-awesome-4.5.0.css" rel="stylesheet">
        <link href="../../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="../../css/highlight.css">
        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

        <script src="../../js/jquery-1.10.2.min.js"></script>
        <script src="../../js/bootstrap-3.0.3.min.js"></script>
        <script src="../../js/highlight.pack.js"></script> 
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="../..">DataLab</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
                <!-- Main navigation -->
                <ul class="nav navbar-nav">
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Home <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                            
<li >
    <a href="../..">Home</a>
</li>
                        </ul>
                    </li>
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Home <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                            
<li >
    <a href="../../About/">About</a>
</li>
                            
<li >
    <a href="../../Cheatsheet/">Cheatsheet</a>
</li>
                            
<li >
    <a href="../../Index/">Index</a>
</li>
                        </ul>
                    </li>
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">常用 <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                            
<li >
    <a href="../../常用/2018-02-23-latex语法/">latex语法.md</a>
</li>
                        </ul>
                    </li>
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">常用工具 <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                            
<li >
    <a href="../../常用工具/2018-02-24-10分钟上手Pandas/">10分钟上手Pandas.md</a>
</li>
                        </ul>
                    </li>
                    <li class="dropdown active">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">机器学习实战 <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                            
<li >
    <a href="../2017-01-01-1.机器学习基础/">1.机器学习基础.md</a>
</li>
                            
<li >
    <a href="../2017-02-01-2.k-近邻算法/">2.k-近邻算法.md</a>
</li>
                            
<li >
    <a href="../2017-03-01-3.决策树/">3.决策树.md</a>
</li>
                            
<li >
    <a href="../2017-04-01-4.朴素贝叶斯/">4.朴素贝叶斯.md</a>
</li>
                            
<li >
    <a href="../2017-04-02-naive-bayes-discuss/">naive-bayes-discuss.md</a>
</li>
                            
<li >
    <a href="../2017-05-01-5.Logistic回归/">5.Logistic回归.md</a>
</li>
                            
<li class="active">
    <a href="./">6.支持向量机.md</a>
</li>
                            
<li >
    <a href="../2017-06-02-6.1.支持向量机的几个通俗理解/">2017 06 02 6.1.支持向量机的几个通俗理解</a>
</li>
                            
<li >
    <a href="../2017-07-01-7.集成方法-随机森林和AdaBoost/">2017 07 01 7.集成方法 随机森林和AdaBoost</a>
</li>
                            
<li >
    <a href="../2017-09-01-9.树回归/">2017 09 01 9.树回归</a>
</li>
                            
<li >
    <a href="../2017-10-01-10.k-means聚类/">2017 10 01 10.k means聚类</a>
</li>
                            
<li >
    <a href="../2017-11-01-11.使用Apriori算法进行关联分析/">2017 11 01 11.使用Apriori算法进行关联分析</a>
</li>
                            
<li >
    <a href="../2017-12-01-12.使用FP-growth算法来高效发现频繁项集/">2017 12 01 12.使用FP growth算法来高效发现频繁项集</a>
</li>
                            
<li >
    <a href="../2018-01-01-13.利用PCA来简化数据/">2018 01 01 13.利用PCA来简化数据</a>
</li>
                            
<li >
    <a href="../2018-02-01-14.利用SVD简化数据/">2018 02 01 14.利用SVD简化数据</a>
</li>
                            
<li >
    <a href="../2018-03-01-15.大数据与MapReduce/">2018 03 01 15.大数据与MapReduce</a>
</li>
                            
<li >
    <a href="../2018-04-01-16.推荐系统/">2018 04 01 16.推荐系统</a>
</li>
                            
<li >
    <a href="../预测数值型数据,回归/">预测数值型数据,回归</a>
</li>
                        </ul>
                    </li>
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">深度学习 <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                            
<li >
    <a href="../../深度学习/2018-02-23-10分钟上手Pandas/">2018 02 23 10分钟上手Pandas</a>
</li>
                            
<li >
    <a href="../../深度学习/2018-02-23-主成分分析 (2)/">2018 02 23 主成分分析 (2)</a>
</li>
                            
<li >
    <a href="../../深度学习/2018-02-23-主成分分析/">2018 02 23 主成分分析</a>
</li>
                            
<li >
    <a href="../../深度学习/2018-02-23-最小二乘法/">2018 02 23 最小二乘法</a>
</li>
                            
<li >
    <a href="../../深度学习/2018-02-23-矩阵分解/">2018 02 23 矩阵分解</a>
</li>
                            
<li >
    <a href="../../深度学习/2018-02-23-矩阵求导/">2018 02 23 矩阵求导</a>
</li>
                        </ul>
                    </li>
                </ul>

            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                        <i class="fa fa-search"></i> Search
                    </a>
                </li>
                    <li >
                        <a rel="next" href="../2017-05-01-5.Logistic回归/">
                            <i class="fa fa-arrow-left"></i> Previous
                        </a>
                    </li>
                    <li >
                        <a rel="prev" href="../2017-06-02-6.1.支持向量机的几个通俗理解/">
                            Next <i class="fa fa-arrow-right"></i>
                        </a>
                    </li>
            </ul>
        </div>
    </div>
</div>

        <div class="container">
                <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
        <li class="main active"><a href="#6">第6章 支持向量机</a></li>
            <li><a href="#_1">支持向量机 概述</a></li>
            <li><a href="#_2">支持向量机 场景</a></li>
            <li><a href="#_3">支持向量机 原理</a></li>
            <li><a href="#kernel">核函数(kernel) 使用</a></li>
    </ul>
</div></div>
                <div class="col-md-9" role="main">

<ul>
<li>content
{:toc}</li>
</ul>
<h1 id="6">第6章 支持向量机</h1>
<h2 id="_1">支持向量机 概述</h2>
<p>支持向量机(Support Vector Machines, SVM)：是一种机器学习算法。
* 支持向量(Support Vector)就是离分隔超平面最近的那些点。
* 机(Machine)就是表示一种算法，而不是表示机器。</p>
<h2 id="_2">支持向量机 场景</h2>
<ul>
<li>要给左右两边的点进行分类</li>
<li>明显发现：选择D会比B、C分隔的效果要好很多。</li>
</ul>
<p>![线性可分]({{ site.baseurl }}{{ site.images }}/MachineLearninginAction/6.SVM/SVM_3_linearly-separable.jpg)</p>
<h2 id="_3">支持向量机 原理</h2>
<h3 id="svm">SVM 工作原理</h3>
<p>![k_2]({{ site.baseurl }}{{ site.images }}/MachineLearninginAction/6.SVM/k_2.jpg "k_2")</p>
<p>对于上述的苹果和香蕉，我们想象为2种水果类型的炸弹。（保证距离最近的炸弹，距离它们最远）</p>
<ol>
<li>寻找最大分类间距</li>
<li>
<p>转而通过拉格朗日函数求优化的问题</p>
</li>
<li>
<p>数据可以通过画一条直线就可以将它们完全分开，这组数据叫<code>线性可分(linearly separable)</code>数据，而这条分隔直线称为<code>分隔超平面(separating hyperplane)</code>。</p>
</li>
<li>如果数据集上升到1024维呢？那么需要1023维来分隔数据集，也就说需要N-1维的对象来分隔，这个对象叫做<code>超平面(hyperlane)</code>，也就是分类的决策边界。</li>
</ol>
<p>![分隔超平面]({{ site.baseurl }}{{ site.images }}/MachineLearninginAction/6.SVM/SVM_2_separating-hyperplane.jpg)</p>
<h3 id="_4">寻找最大间隔</h3>
<h4 id="_5">为什么寻找最大间隔</h4>
<div class="highlight"><pre><span></span>摘录地址：http://slideplayer.com/slide/8610144  (第12条信息)
Support Vector Machines: Slide 12 Copyright © 2001, 2003, Andrew W. Moore Why Maximum Margin? 
denotes +1 denotes -1 f(x,w,b) = sign(w. x - b) The maximum margin linear classifier is the linear classifier with the, um, maximum margin. 
This is the simplest kind of SVM (Called an LSVM) Support Vectors are those datapoints that the margin pushes up against 

1.Intuitively this feels safest. 
2.If we’ve made a small error in the location of the boundary (it’s been jolted in its perpendicular direction) this gives us least chance of causing a misclassification. 
3.CV is easy since the model is immune to removal of any non-support-vector datapoints. 
4.There’s some theory that this is a good thing. 
5.Empirically it works very very well. 

* * *

1. 直觉上是安全的
2. 如果我们在边界的位置发生了一个小错误（它在垂直方向上被颠倒），这给我们最小的错误分类机会。
3. CV（Computer Vision 计算机视觉 - 这缩写看着可怕）很容易，因为该模型对任何非支持向量数据点的去除是免疫的。
4. 有一些理论，这是一件好事。
5. 通常它的工作非常好。
</pre></div>

<h4 id="_6">怎么寻找最大间隔</h4>
<blockquote>
<p>点到超平面的距离</p>
</blockquote>
<ul>
<li>分隔超平面<code>函数间距</code>: $ y(x)=w^Tx+b $</li>
<li>分类的结果： $ f(x)=sign(w^Tx+b) $  (sign表示符号函数，&gt;0为1，&lt;0为-1，=0为0) </li>
<li>修改点到超平面的 <code>几何间距</code> :  $ d(x)=\frac{(w^Tx+b)}{\lVert w \rVert} $  （ <span><span class="MathJax_Preview">\lVert w \rVert</span><script type="math/tex">\lVert w \rVert</script></span> 表示w矩阵的二范式=&gt;  <span><span class="MathJax_Preview">\sqrt{w*w^T}</span><script type="math/tex">\sqrt{w*w^T}</script></span>  , 点到超平面的距离也是类似的）  </li>
</ul>
<p>![点到直线的几何距离]({{ site.baseurl }}{{ site.images }}/MachineLearninginAction/6.SVM/SVM_4_point2line-distance.jpg)</p>
<blockquote>
<p>拉格朗日乘子法</p>
</blockquote>
<ul>
<li>类别标签用-1、1，是为了后期方便  $lable\bullet(w^Tx+b) $ 的标识和距离计算；如果  $ lable\bullet(w^Tx+b)&gt;0 $  表示预测正确，否则预测错误。</li>
<li>现在目标很明确，就是要找到<code>w</code>和<code>b</code>，因此我们必须要找到最小间隔的数据点，也就是前面所说的<code>支持向量</code>。<ul>
<li>也就说，让最小的距离取最大.(最小的距离：就是最小间隔的数据点；最大：就是最大间距，为了找出最优超平面--最终就是支持向量)</li>
<li>目标函数： $ arg: max \left( min[lable\bullet(w^Tx+b)]\bullet\frac{1}{\lVert w \rVert} \right) $ <ol>
<li>如果  $ lable*(w^Tx+b)&gt;0 $  表示预测正确，也称<code>函数间隔</code>， $ \lVert w \rVert $  可以理解为归一化，也称<code>几何间隔</code>。</li>
<li>令  <span><span class="MathJax_Preview">lable\bullet(w^Tx+b)&gt;=1</span><script type="math/tex">lable\bullet(w^Tx+b)>=1</script></span> ， 因为0～1之间，得到的点是存在误判的可能性，所以要保障  <span><span class="MathJax_Preview">min[lable\bullet(w^Tx+b)]=1</span><script type="math/tex">min[lable\bullet(w^Tx+b)]=1</script></span> ，才能更好降低噪音数据影响。</li>
<li>所以本质上是求  $arg: max_{关于w, b}  \frac{1}{ \lVert w \rVert } $ ；也就说，我们约束(前提)条件是:  <span><span class="MathJax_Preview">lable*(w^Tx+b)=1</span><script type="math/tex">lable*(w^Tx+b)=1</script></span> </li>
</ol>
</li>
</ul>
</li>
<li>新的目标函数求解：$ arg: max_{关于w, b}  \frac{1}{ \lVert w \rVert } $ <ul>
<li>=&gt; 就是求:  $arg: min_{关于w, b}  \lVert w \rVert  $  (求矩阵会比较麻烦，如果x只是  <span><span class="MathJax_Preview">\frac{1}{2}\bullet x^2</span><script type="math/tex">\frac{1}{2}\bullet x^2</script></span>  的偏导数，那么。。同样是求最小值)</li>
<li>=&gt; 就是求:  <span><span class="MathJax_Preview">arg: min_{关于w, b} (\frac{1}{2}\bullet \lVert w \rVert ^2)</span><script type="math/tex">arg: min_{关于w, b} (\frac{1}{2}\bullet \lVert w \rVert ^2)</script></span>  (二次函数求导，求极值，平方也方便计算)</li>
<li>本质上就是求线性不等式的二次优化问题(求分隔超平面，等价于求解相应的凸二次规划问题)</li>
</ul>
</li>
<li>通过拉格朗日乘子法，求二次优化问题<ul>
<li>假设需要求极值的目标函数 (objective function) 为 f(x,y)，限制条件为 φ(x,y)=M  # M=1</li>
<li>设g(x,y)=M-φ(x,y)   # 临时φ(x,y)表示下文中  <span><span class="MathJax_Preview">label\bullet(w^Tx+b)</span><script type="math/tex">label\bullet(w^Tx+b)</script></span> </li>
<li>定义一个新函数: F(x,y,λ)=f(x,y)+λg(x,y)</li>
<li>a为λ（a&gt;=0），代表要引入的拉格朗日乘子(Lagrange multiplier)</li>
<li>那么：  <span><span class="MathJax_Preview">L(w,b,\alpha)=\frac{1}{2} \bullet  \lVert w \rVert ^2 + \sum_{i=1}^{n} \alpha_i \bullet [1 - label \bullet (w^Tx+b)]</span><script type="math/tex">L(w,b,\alpha)=\frac{1}{2} \bullet  \lVert w \rVert ^2 + \sum_{i=1}^{n} \alpha_i \bullet [1 - label \bullet (w^Tx+b)]</script></span> </li>
<li>因为： <span><span class="MathJax_Preview">label\bullet(w^Tx+b)&gt;=1, \alpha&gt;=0</span><script type="math/tex">label\bullet(w^Tx+b)>=1, \alpha>=0</script></span>  , 所以  <span><span class="MathJax_Preview">\alpha\bullet[1-label\bullet(w^Tx+b)]&lt;=0</span><script type="math/tex">\alpha\bullet[1-label\bullet(w^Tx+b)]<=0</script></span>  ,  <span><span class="MathJax_Preview">\sum_{i=1}^{n} \alpha_i \bullet [1-label*(w^Tx+b)]&lt;=0</span><script type="math/tex">\sum_{i=1}^{n} \alpha_i \bullet [1-label*(w^Tx+b)]<=0</script></span>  </li>
<li>当  <span><span class="MathJax_Preview">label\bullet(w^Tx+b)&gt;1</span><script type="math/tex">label\bullet(w^Tx+b)>1</script></span>  则  <span><span class="MathJax_Preview">\alpha=0</span><script type="math/tex">\alpha=0</script></span>  ，表示该点为<font color=red>非支持向量</font></li>
<li>相当于求解：  <span><span class="MathJax_Preview">max_{关于\alpha} L(w,b,\alpha) = \frac{1}{2} \bullet \lVert w \rVert ^2</span><script type="math/tex">max_{关于\alpha} L(w,b,\alpha) = \frac{1}{2} \bullet \lVert w \rVert ^2</script></span>  </li>
<li>如果求：  <span><span class="MathJax_Preview">min_{关于w, b} \frac{1}{2} * \lVert w \rVert ^2</span><script type="math/tex">min_{关于w, b} \frac{1}{2} * \lVert w \rVert ^2</script></span>  , 也就是要求：  <span><span class="MathJax_Preview">min_{关于w, b} \left( max_{关于\alpha} L(w,b,\alpha)\right)</span><script type="math/tex">min_{关于w, b} \left( max_{关于\alpha} L(w,b,\alpha)\right)</script></span>  </li>
</ul>
</li>
<li>现在转化到对偶问题的求解<ul>
<li>$min_{关于w, b} \left(max_{关于\alpha} L(w,b,\alpha) \right) $  &gt;=  $max_{关于\alpha} \left(min_{关于w, b} L(w,b,\alpha) \right) $  </li>
<li>现在分2步</li>
<li>先求：  <span><span class="MathJax_Preview">min_{关于w, b} L(w,b,\alpha)=\frac{1}{2} \bullet  \lVert w \rVert ^2 + \sum_{i=1}^{n} \alpha_i \bullet [1 - label \bullet (w^Tx+b)]</span><script type="math/tex">min_{关于w, b} L(w,b,\alpha)=\frac{1}{2} \bullet  \lVert w \rVert ^2 + \sum_{i=1}^{n} \alpha_i \bullet [1 - label \bullet (w^Tx+b)]</script></span> </li>
<li>就是求<code>L(w,b,a)</code>关于[w, b]的偏导数, 得到<code>w和b的值</code>，并化简为：<code>L和a的方程</code>。</li>
<li>参考： 如果公式推导还是不懂，也可以参考《统计学习方法》李航-P103&lt;学习的对偶算法&gt;
![计算拉格朗日函数的对偶函数]({{ site.baseurl }}{{ site.images }}/MachineLearninginAction/6.SVM/SVM_5_Lagrangemultiplier.png)</li>
</ul>
</li>
<li>终于得到课本上的公式：  $max_{关于\alpha} \left( \sum_{i=1}^{m} \alpha_i - \frac{1}{2} \sum_{i, j=1}^{m} label_i·label_j·\alpha_i·\alpha_j·<x_i, x_j> \right) $ </li>
<li>约束条件：  <span><span class="MathJax_Preview">a&gt;=0</span><script type="math/tex">a>=0</script></span>  并且  <span><span class="MathJax_Preview">\sum_{i=1}^{m} a_i·label_i=0</span><script type="math/tex">\sum_{i=1}^{m} a_i·label_i=0</script></span> </li>
</ul>
<blockquote>
<p>松弛变量(slack variable)</p>
</blockquote>
<p>参考地址：<a href="http://blog.csdn.net/wusecaiyun/article/details/49659183">http://blog.csdn.net/wusecaiyun/article/details/49659183</a></p>
<p>![松弛变量公式]({{ site.baseurl }}{{ site.images }}/MachineLearninginAction/6.SVM/SVM_松弛变量.jpg)</p>
<ul>
<li>我们知道几乎所有的数据都不那么干净, 通过引入松弛变量来 <code>允许数据点可以处于分隔面错误的一侧</code>。</li>
<li>约束条件：  <span><span class="MathJax_Preview">C&gt;=a&gt;=0</span><script type="math/tex">C>=a>=0</script></span>  并且  <span><span class="MathJax_Preview">\sum_{i=1}^{m} a_i·label_i=0</span><script type="math/tex">\sum_{i=1}^{m} a_i·label_i=0</script></span> </li>
<li>总的来说：<ul>
<li>![松弛变量]({{ site.baseurl }}{{ site.images }}/MachineLearninginAction/6.SVM/松弛变量.png) 表示 <code>松弛变量</code></li>
<li>常量C是 <code>惩罚因子</code>, 表示离群点的权重（用于控制“最大化间隔”和“保证大部分点的函数间隔小于1.0” ）<ul>
<li><span><span class="MathJax_Preview">label*(w^Tx+b) &gt; 1</span><script type="math/tex">label*(w^Tx+b) > 1</script></span>  and alpha = 0 (在边界外，就是非支持向量)</li>
<li><span><span class="MathJax_Preview">label*(w^Tx+b) = 1</span><script type="math/tex">label*(w^Tx+b) = 1</script></span>  and 0&lt; alpha &lt; C (在分割超平面上，就支持向量)</li>
<li><span><span class="MathJax_Preview">label*(w^Tx+b) &lt; 1</span><script type="math/tex">label*(w^Tx+b) < 1</script></span>  and alpha = C (在分割超平面内，是误差点 -&gt; C表示它该受到的惩罚因子程度)</li>
<li>参考地址：<a href="https://www.zhihu.com/question/48351234/answer/110486455">https://www.zhihu.com/question/48351234/answer/110486455</a></li>
</ul>
</li>
<li>C值越大，表示离群点影响越大，就越容易过度拟合；反之有可能欠拟合。</li>
<li>我们看到，目标函数控制了离群点的数目和程度，使大部分样本点仍然遵守限制条件。</li>
<li>例如：正类有10000个样本，而负类只给了100个（C越大表示100个负样本的影响越大，就会出现过度拟合，所以C决定了负样本对模型拟合程度的影响！，C就是一个非常关键的优化点！）</li>
</ul>
</li>
<li>这一结论十分直接，SVM中的主要工作就是要求解 alpha.</li>
</ul>
<h3 id="smo">SMO 高效优化算法</h3>
<ul>
<li>SVM有很多种实现，最流行的一种实现是： <code>序列最小优化(Sequential Minimal Optimization, SMO)算法</code>。</li>
<li>下面还会介绍一种称为 <code>核函数(kernel)</code> 的方式将SVM扩展到更多数据集上。</li>
<li>注意：<code>SVM几何含义比较直观，但其算法实现较复杂，牵扯大量数学公式的推导。</code></li>
</ul>
<blockquote>
<p>序列最小优化(Sequential Minimal Optimization, SMO)</p>
</blockquote>
<ul>
<li>创建作者：John Platt</li>
<li>创建时间：1996年</li>
<li>SMO用途：用于训练 SVM</li>
<li>SMO目标：求出一系列 alpha 和 b,一旦求出 alpha，就很容易计算出权重向量 w 并得到分隔超平面。</li>
<li>SMO思想：是将大优化问题分解为多个小优化问题来求解的。</li>
<li>SMO原理：每次循环选择两个 alpha 进行优化处理，一旦找出一对合适的 alpha，那么就增大一个同时减少一个。<ul>
<li>这里指的合适必须要符合一定的条件<ol>
<li>这两个 alpha 必须要在间隔边界之外</li>
<li>这两个 alpha 还没有进行过区间化处理或者不在边界上。</li>
</ol>
</li>
<li>之所以要同时改变2个 alpha；原因是我们有一个约束条件：  <span><span class="MathJax_Preview">\sum_{i=1}^{m} a_i·label_i=0</span><script type="math/tex">\sum_{i=1}^{m} a_i·label_i=0</script></span> ；如果只是修改一个 alpha，很可能导致约束条件失效。</li>
</ul>
</li>
</ul>
<blockquote>
<p>SMO 伪代码大致如下：</p>
</blockquote>
<div class="highlight"><pre><span></span>创建一个 alpha 向量并将其初始化为0向量
当迭代次数小于最大迭代次数时(外循环)
    对数据集中的每个数据向量(内循环)：
        如果该数据向量可以被优化
            随机选择另外一个数据向量
            同时优化这两个向量
            如果两个向量都不能被优化，退出内循环
    如果所有向量都没被优化，增加迭代数目，继续下一次循环
</pre></div>

<h3 id="svm_1">SVM 开发流程</h3>
<div class="highlight"><pre><span></span>收集数据：可以使用任意方法。
准备数据：需要数值型数据。
分析数据：有助于可视化分隔超平面。
训练算法：SVM的大部分时间都源自训练，该过程主要实现两个参数的调优。
测试算法：十分简单的计算过程就可以实现。
使用算法：几乎所有分类问题都可以使用SVM，值得一提的是，SVM本身是一个二类分类器，对多类问题应用SVM需要对代码做一些修改。
</pre></div>

<h3 id="svm_2">SVM 算法特点</h3>
<div class="highlight"><pre><span></span>优点：泛化（由具体的、个别的扩大为一般的，就是说：模型训练完后的新样本）错误率低，计算开销不大，结果易理解。
缺点：对参数调节和核函数的选择敏感，原始分类器不加修改仅适合于处理二分类问题。
使用数据类型：数值型和标称型数据。
</pre></div>

<h3 id="_7">课本案例（无核函数）</h3>
<h4 id="_8">项目概述</h4>
<p>对小规模数据点进行分类</p>
<h4 id="_9">开发流程</h4>
<blockquote>
<p>收集数据</p>
</blockquote>
<p>文本文件格式：</p>
<div class="highlight"><pre><span></span><span class="mf">3.542485</span>    <span class="mf">1.977398</span>    <span class="o">-</span><span class="mi">1</span>
<span class="mf">3.018896</span>    <span class="mf">2.556416</span>    <span class="o">-</span><span class="mi">1</span>
<span class="mf">7.551510</span>    <span class="o">-</span><span class="mf">1.580030</span>   <span class="mi">1</span>
<span class="mf">2.114999</span>    <span class="o">-</span><span class="mf">0.004466</span>   <span class="o">-</span><span class="mi">1</span>
<span class="mf">8.127113</span>    <span class="mf">1.274372</span>    <span class="mi">1</span>
</pre></div>

<blockquote>
<p>准备数据</p>
</blockquote>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">loadDataSet</span><span class="p">(</span><span class="n">fileName</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    对文件进行逐行解析，从而得到第行的类标签和整个特征矩阵</span>
<span class="sd">    Args:</span>
<span class="sd">        fileName 文件名</span>
<span class="sd">    Returns:</span>
<span class="sd">        dataMat  特征矩阵</span>
<span class="sd">        labelMat 类标签</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dataMat</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">labelMat</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">fr</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">fileName</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">fr</span><span class="o">.</span><span class="n">readlines</span><span class="p">():</span>
        <span class="n">lineArr</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">dataMat</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">lineArr</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">float</span><span class="p">(</span><span class="n">lineArr</span><span class="p">[</span><span class="mi">1</span><span class="p">])])</span>
        <span class="n">labelMat</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">lineArr</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
    <span class="k">return</span> <span class="n">dataMat</span><span class="p">,</span> <span class="n">labelMat</span>
</pre></div>

<blockquote>
<p>分析数据: 无</p>
<p>训练算法</p>
</blockquote>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">smoSimple</span><span class="p">(</span><span class="n">dataMatIn</span><span class="p">,</span> <span class="n">classLabels</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">toler</span><span class="p">,</span> <span class="n">maxIter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;smoSimple</span>

<span class="sd">    Args:</span>
<span class="sd">        dataMatIn    特征集合</span>
<span class="sd">        classLabels  类别标签</span>
<span class="sd">        C   松弛变量(常量值)，允许有些数据点可以处于分隔面的错误一侧。</span>
<span class="sd">            控制最大化间隔和保证大部分的函数间隔小于1.0这两个目标的权重。</span>
<span class="sd">            可以通过调节该参数达到不同的结果。</span>
<span class="sd">        toler   容错率（是指在某个体系中能减小一些因素或选择对某个系统产生不稳定的概率。）</span>
<span class="sd">        maxIter 退出前最大的循环次数</span>
<span class="sd">    Returns:</span>
<span class="sd">        b       模型的常量值</span>
<span class="sd">        alphas  拉格朗日乘子</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dataMatrix</span> <span class="o">=</span> <span class="n">mat</span><span class="p">(</span><span class="n">dataMatIn</span><span class="p">)</span>
    <span class="c1"># 矩阵转置 和 .T 一样的功能</span>
    <span class="n">labelMat</span> <span class="o">=</span> <span class="n">mat</span><span class="p">(</span><span class="n">classLabels</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
    <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">shape</span><span class="p">(</span><span class="n">dataMatrix</span><span class="p">)</span>

    <span class="c1"># 初始化 b和alphas(alpha有点类似权重值。)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">alphas</span> <span class="o">=</span> <span class="n">mat</span><span class="p">(</span><span class="n">zeros</span><span class="p">((</span><span class="n">m</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>

    <span class="c1"># 没有任何alpha改变的情况下遍历数据的次数</span>
    <span class="nb">iter</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="p">(</span><span class="nb">iter</span> <span class="o">&lt;</span> <span class="n">maxIter</span><span class="p">):</span>
        <span class="c1"># w = calcWs(alphas, dataMatIn, classLabels)</span>
        <span class="c1"># print(&quot;w:&quot;, w)</span>

        <span class="c1"># 记录alpha是否已经进行优化，每次循环时设为0，然后再对整个集合顺序遍历</span>
        <span class="n">alphaPairsChanged</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
            <span class="c1"># print &#39;alphas=&#39;, alphas</span>
            <span class="c1"># print &#39;labelMat=&#39;, labelMat</span>
            <span class="c1"># print &#39;multiply(alphas, labelMat)=&#39;, multiply(alphas, labelMat)</span>
            <span class="c1"># 我们预测的类别 y[i] = w^Tx[i]+b; 其中因为 w = Σ(1~n) a[n]*lable[n]*x[n]</span>
            <span class="n">fXi</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">multiply</span><span class="p">(</span><span class="n">alphas</span><span class="p">,</span> <span class="n">labelMat</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="o">*</span><span class="p">(</span><span class="n">dataMatrix</span><span class="o">*</span><span class="n">dataMatrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">T</span><span class="p">))</span> <span class="o">+</span> <span class="n">b</span>
            <span class="c1"># 预测结果与真实结果比对，计算误差Ei</span>
            <span class="n">Ei</span> <span class="o">=</span> <span class="n">fXi</span> <span class="o">-</span> <span class="nb">float</span><span class="p">(</span><span class="n">labelMat</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

            <span class="c1"># 约束条件 (KKT条件是解决最优化问题的时用到的一种方法。我们这里提到的最优化问题通常是指对于给定的某一函数，求其在指定作用域上的全局最小值)</span>
            <span class="c1"># 0&lt;=alphas[i]&lt;=C，但由于0和C是边界值，我们无法进行优化，因为需要增加一个alphas和降低一个alphas。</span>
            <span class="c1"># 表示发生错误的概率：labelMat[i]*Ei 如果超出了 toler， 才需要优化。至于正负号，我们考虑绝对值就对了。</span>
            <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            # 检验训练样本(xi, yi)是否满足KKT条件</span>
<span class="sd">            yi*f(i) &gt;= 1 and alpha = 0 (outside the boundary)</span>
<span class="sd">            yi*f(i) == 1 and 0&lt;alpha&lt; C (on the boundary)</span>
<span class="sd">            yi*f(i) &lt;= 1 and alpha = C (between the boundary)</span>
<span class="sd">            &#39;&#39;&#39;</span>
            <span class="k">if</span> <span class="p">((</span><span class="n">labelMat</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">Ei</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">toler</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">alphas</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">C</span><span class="p">))</span> <span class="ow">or</span> <span class="p">((</span><span class="n">labelMat</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">Ei</span> <span class="o">&gt;</span> <span class="n">toler</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">alphas</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)):</span>

                <span class="c1"># 如果满足优化的条件，我们就随机选取非i的一个点，进行优化比较</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">selectJrand</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
                <span class="c1"># 预测j的结果</span>
                <span class="n">fXj</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">multiply</span><span class="p">(</span><span class="n">alphas</span><span class="p">,</span> <span class="n">labelMat</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="o">*</span><span class="p">(</span><span class="n">dataMatrix</span><span class="o">*</span><span class="n">dataMatrix</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">T</span><span class="p">))</span> <span class="o">+</span> <span class="n">b</span>
                <span class="n">Ej</span> <span class="o">=</span> <span class="n">fXj</span> <span class="o">-</span> <span class="nb">float</span><span class="p">(</span><span class="n">labelMat</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                <span class="n">alphaIold</span> <span class="o">=</span> <span class="n">alphas</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">alphaJold</span> <span class="o">=</span> <span class="n">alphas</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

                <span class="c1"># L和H用于将alphas[j]调整到0-C之间。如果L==H，就不做任何改变，直接执行continue语句</span>
                <span class="c1"># labelMat[i] != labelMat[j] 表示异侧，就相减，否则是同侧，就相加。</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">labelMat</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">labelMat</span><span class="p">[</span><span class="n">j</span><span class="p">]):</span>
                    <span class="n">L</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">alphas</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">alphas</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="n">H</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">C</span> <span class="o">+</span> <span class="n">alphas</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">alphas</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">L</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">alphas</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">alphas</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">C</span><span class="p">)</span>
                    <span class="n">H</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">alphas</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">alphas</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="c1"># 如果相同，就没发优化了</span>
                <span class="k">if</span> <span class="n">L</span> <span class="o">==</span> <span class="n">H</span><span class="p">:</span>
                    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;L==H&quot;</span><span class="p">)</span>
                    <span class="k">continue</span>

                <span class="c1"># eta是alphas[j]的最优修改量，如果eta==0，需要退出for循环的当前迭代过程</span>
                <span class="c1"># 参考《统计学习方法》李航-P125~P128&lt;序列最小最优化算法&gt;</span>
                <span class="n">eta</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">dataMatrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span><span class="o">*</span><span class="n">dataMatrix</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">T</span> <span class="o">-</span> <span class="n">dataMatrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span><span class="o">*</span><span class="n">dataMatrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">T</span> <span class="o">-</span> <span class="n">dataMatrix</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:]</span><span class="o">*</span><span class="n">dataMatrix</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">T</span>
                <span class="k">if</span> <span class="n">eta</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;eta&gt;=0&quot;</span><span class="p">)</span>
                    <span class="k">continue</span>

                <span class="c1"># 计算出一个新的alphas[j]值</span>
                <span class="n">alphas</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-=</span> <span class="n">labelMat</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">Ei</span> <span class="o">-</span> <span class="n">Ej</span><span class="p">)</span><span class="o">/</span><span class="n">eta</span>
                <span class="c1"># 并使用辅助函数，以及L和H对其进行调整</span>
                <span class="n">alphas</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">clipAlpha</span><span class="p">(</span><span class="n">alphas</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">H</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span>
                <span class="c1"># 检查alpha[j]是否只是轻微的改变，如果是的话，就退出for循环。</span>
                <span class="k">if</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">alphas</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">alphaJold</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">0.00001</span><span class="p">):</span>
                    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;j not moving enough&quot;</span><span class="p">)</span>
                    <span class="k">continue</span>
                <span class="c1"># 然后alphas[i]和alphas[j]同样进行改变，虽然改变的大小一样，但是改变的方向正好相反</span>
                <span class="n">alphas</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">labelMat</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">labelMat</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">alphaJold</span> <span class="o">-</span> <span class="n">alphas</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                <span class="c1"># 在对alpha[i], alpha[j] 进行优化之后，给这两个alpha值设置一个常数b。</span>
                <span class="c1"># w= Σ[1~n] ai*yi*xi =&gt; b = yj- Σ[1~n] ai*yi(xi*xj)</span>
                <span class="c1"># 所以：  b1 - b = (y1-y) - Σ[1~n] yi*(a1-a)*(xi*x1)</span>
                <span class="c1"># 为什么减2遍？ 因为是 减去Σ[1~n]，正好2个变量i和j，所以减2遍</span>
                <span class="n">b1</span> <span class="o">=</span> <span class="n">b</span> <span class="o">-</span> <span class="n">Ei</span><span class="o">-</span> <span class="n">labelMat</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">alphas</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">alphaIold</span><span class="p">)</span><span class="o">*</span><span class="n">dataMatrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span><span class="o">*</span><span class="n">dataMatrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">T</span> <span class="o">-</span> <span class="n">labelMat</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">alphas</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-</span><span class="n">alphaJold</span><span class="p">)</span><span class="o">*</span><span class="n">dataMatrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span><span class="o">*</span><span class="n">dataMatrix</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">T</span>
                <span class="n">b2</span> <span class="o">=</span> <span class="n">b</span> <span class="o">-</span> <span class="n">Ej</span><span class="o">-</span> <span class="n">labelMat</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">alphas</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">alphaIold</span><span class="p">)</span><span class="o">*</span><span class="n">dataMatrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span><span class="o">*</span><span class="n">dataMatrix</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">T</span> <span class="o">-</span> <span class="n">labelMat</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">alphas</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-</span><span class="n">alphaJold</span><span class="p">)</span><span class="o">*</span><span class="n">dataMatrix</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:]</span><span class="o">*</span><span class="n">dataMatrix</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">T</span>
                <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;</span> <span class="n">alphas</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="ow">and</span> <span class="p">(</span><span class="n">C</span> <span class="o">&gt;</span> <span class="n">alphas</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span>
                    <span class="n">b</span> <span class="o">=</span> <span class="n">b1</span>
                <span class="k">elif</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;</span> <span class="n">alphas</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="ow">and</span> <span class="p">(</span><span class="n">C</span> <span class="o">&gt;</span> <span class="n">alphas</span><span class="p">[</span><span class="n">j</span><span class="p">]):</span>
                    <span class="n">b</span> <span class="o">=</span> <span class="n">b2</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="n">b1</span> <span class="o">+</span> <span class="n">b2</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span>
                <span class="n">alphaPairsChanged</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">print</span><span class="p">(</span><span class="s2">&quot;iter: </span><span class="si">%d</span><span class="s2"> i:</span><span class="si">%d</span><span class="s2">, pairs changed </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">iter</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">alphaPairsChanged</span><span class="p">))</span>
        <span class="c1"># 在for循环外，检查alpha值是否做了更新，如果在更新则将iter设为0后继续运行程序</span>
        <span class="c1"># 知道更新完毕后，iter次循环无变化，才推出循环。</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">alphaPairsChanged</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="nb">iter</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">iter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;iteration number: </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">iter</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">b</span><span class="p">,</span> <span class="n">alphas</span>
</pre></div>

<p><a href="https://github.com/apachecn/MachineLearning/blob/master/src/python/6.SVM/svm-simple.py">完整代码地址：SVM简化版，应用简化版SMO算法处理小规模数据集</a>: <a href="https://github.com/apachecn/MachineLearning/blob/master/src/python/6.SVM/svm-simple.py">https://github.com/apachecn/MachineLearning/blob/master/src/python/6.SVM/svm-simple.py</a></p>
<p><a href="https://github.com/apachecn/MachineLearning/blob/master/src/python/6.SVM/svm-complete_Non-Kernel.py">完整代码地址：SVM完整版，使用完整 Platt SMO算法加速优化，优化点：选择alpha的方式不同</a>: <a href="https://github.com/apachecn/MachineLearning/blob/master/src/python/6.SVM/svm-complete_Non-Kernel.py">https://github.com/apachecn/MachineLearning/blob/master/src/python/6.SVM/svm-complete_Non-Kernel.py</a></p>
<h2 id="kernel">核函数(kernel) 使用</h2>
<ul>
<li>对于线性可分的情况，效果明显</li>
<li>对于非线性的情况也一样，此时需要用到一种叫<code>核函数(kernel)</code>的工具将数据转化为分类器易于理解的形式。</li>
</ul>
<blockquote>
<p>利用核函数将数据映射到高维空间</p>
</blockquote>
<ul>
<li>使用核函数：可以将数据从某个特征空间到另一个特征空间的映射。（通常情况下：这种映射会将低维特征空间映射到高维空间。）</li>
<li>如果觉得特征空间很装逼、很难理解。</li>
<li>可以把核函数想象成一个包装器(wrapper)或者是接口(interface)，它能将数据从某个很难处理的形式转换成为另一个较容易处理的形式。</li>
<li>经过空间转换后：低维需要解决的非线性问题，就变成了高维需要解决的线性问题。</li>
<li>SVM 优化特别好的地方，在于所有的运算都可以写成内积(inner product: 是指2个向量相乘，得到单个标量 或者 数值)；内积替换成核函数的方式被称为<code>核技巧(kernel trick)</code>或者<code>核&quot;变电&quot;(kernel substation)</code></li>
<li>核函数并不仅仅应用于支持向量机，很多其他的机器学习算法也都用到核函数。最流行的核函数：径向基函数(radial basis function)</li>
<li>径向基函数的高斯版本，其具体的公式为：</li>
</ul>
<p>![径向基函数的高斯版本]({{ site.baseurl }}{{ site.images }}/MachineLearninginAction/6.SVM/SVM_6_radial-basis-function.jpg)</p>
<h3 id="_10">项目案例: 手写数字识别的优化（有核函数）</h3>
<h4 id="_11">项目概述</h4>
<div class="highlight"><pre><span></span><span class="err">你的老板要求：你写的那个手写识别程序非常好，但是它占用内存太大。顾客无法通过无线的方式下载我们的应用。</span>
<span class="err">所以：我们可以考虑使用支持向量机，保留支持向量就行（</span><span class="n">knn</span><span class="err">需要保留所有的向量），就可以获得非常好的效果。</span>
</pre></div>

<h4 id="_12">开发流程</h4>
<blockquote>
<p>收集数据：提供的文本文件</p>
</blockquote>
<div class="highlight"><pre><span></span><span class="mo">00000000000000001111000000000000</span>
<span class="mo">00000000000000011111111000000000</span>
<span class="mo">00000000000000011111111100000000</span>
<span class="mo">00000000000000011111111110000000</span>
<span class="mo">00000000000000011111111110000000</span>
<span class="mo">00000000000000111111111100000000</span>
<span class="mo">00000000000000111111111100000000</span>
<span class="mo">00000000000001111111111100000000</span>
<span class="mo">00000000000000111111111100000000</span>
<span class="mo">00000000000000111111111100000000</span>
<span class="mo">00000000000000111111111000000000</span>
<span class="mo">00000000000001111111111000000000</span>
<span class="mo">00000000000011111111111000000000</span>
<span class="mo">00000000000111111111110000000000</span>
<span class="mo">00000000001111111111111000000000</span>
<span class="mo">00000001111111111111111000000000</span>
<span class="mo">00000011111111111111110000000000</span>
<span class="mo">00000111111111111111110000000000</span>
<span class="mo">00000111111111111111110000000000</span>
<span class="mo">00000001111111111111110000000000</span>
<span class="mo">00000001111111011111110000000000</span>
<span class="mo">00000000111100011111110000000000</span>
<span class="mo">00000000000000011111110000000000</span>
<span class="mo">00000000000000011111100000000000</span>
<span class="mo">00000000000000111111110000000000</span>
<span class="mo">00000000000000011111110000000000</span>
<span class="mo">00000000000000011111110000000000</span>
<span class="mo">00000000000000011111111000000000</span>
<span class="mo">00000000000000011111111000000000</span>
<span class="mo">00000000000000011111111000000000</span>
<span class="mo">00000000000000000111111110000000</span>
<span class="mo">00000000000000000111111100000000</span>
</pre></div>

<blockquote>
<p>准备数据：基于二值图像构造向量</p>
</blockquote>
<p><code>将 32*32的文本转化为 1*1024的矩阵</code></p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">img2vector</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="n">returnVect</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1024</span><span class="p">))</span>
    <span class="n">fr</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">32</span><span class="p">):</span>
        <span class="n">lineStr</span> <span class="o">=</span> <span class="n">fr</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">32</span><span class="p">):</span>
            <span class="n">returnVect</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">32</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">lineStr</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">returnVect</span>

<span class="k">def</span> <span class="nf">loadImages</span><span class="p">(</span><span class="n">dirName</span><span class="p">):</span>
    <span class="kn">from</span> <span class="nn">os</span> <span class="kn">import</span> <span class="n">listdir</span>
    <span class="n">hwLabels</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">print</span><span class="p">(</span><span class="n">dirName</span><span class="p">)</span>
    <span class="n">trainingFileList</span> <span class="o">=</span> <span class="n">listdir</span><span class="p">(</span><span class="n">dirName</span><span class="p">)</span>  <span class="c1"># load the training set</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">trainingFileList</span><span class="p">)</span>
    <span class="n">trainingMat</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="n">m</span><span class="p">,</span> <span class="mi">1024</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
        <span class="n">fileNameStr</span> <span class="o">=</span> <span class="n">trainingFileList</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">fileStr</span> <span class="o">=</span> <span class="n">fileNameStr</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># take off .txt</span>
        <span class="n">classNumStr</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">fileStr</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">classNumStr</span> <span class="o">==</span> <span class="mi">9</span><span class="p">:</span>
            <span class="n">hwLabels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">hwLabels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">trainingMat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">img2vector</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">/</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">dirName</span><span class="p">,</span> <span class="n">fileNameStr</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">trainingMat</span><span class="p">,</span> <span class="n">hwLabels</span>
</pre></div>

<blockquote>
<p>分析数据：对图像向量进行目测</p>
<p>训练算法：采用两种不同的核函数，并对径向基核函数采用不同的设置来运行SMO算法</p>
</blockquote>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">kernelTrans</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">kTup</span><span class="p">):</span>  <span class="c1"># calc the kernel or transform data to a higher dimensional space</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    核转换函数</span>
<span class="sd">    Args:</span>
<span class="sd">        X     dataMatIn数据集</span>
<span class="sd">        A     dataMatIn数据集的第i行的数据</span>
<span class="sd">        kTup  核函数的信息</span>

<span class="sd">    Returns:</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">shape</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
    <span class="n">K</span> <span class="o">=</span> <span class="n">mat</span><span class="p">(</span><span class="n">zeros</span><span class="p">((</span><span class="n">m</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>
    <span class="k">if</span> <span class="n">kTup</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;lin&#39;</span><span class="p">:</span>
        <span class="c1"># linear kernel:   m*n * n*1 = m*1</span>
        <span class="n">K</span> <span class="o">=</span> <span class="n">X</span> <span class="o">*</span> <span class="n">A</span><span class="o">.</span><span class="n">T</span>
    <span class="k">elif</span> <span class="n">kTup</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;rbf&#39;</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
            <span class="n">deltaRow</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">A</span>
            <span class="n">K</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">deltaRow</span> <span class="o">*</span> <span class="n">deltaRow</span><span class="o">.</span><span class="n">T</span>
        <span class="c1"># 径向基函数的高斯版本</span>
        <span class="n">K</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="n">K</span> <span class="o">/</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">kTup</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>  <span class="c1"># divide in NumPy is element-wise not matrix like Matlab</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s1">&#39;Houston We Have a Problem -- That Kernel is not recognized&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">K</span>

<span class="k">def</span> <span class="nf">smoP</span><span class="p">(</span><span class="n">dataMatIn</span><span class="p">,</span> <span class="n">classLabels</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">toler</span><span class="p">,</span> <span class="n">maxIter</span><span class="p">,</span> <span class="n">kTup</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;lin&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    完整SMO算法外循环，与smoSimple有些类似，但这里的循环退出条件更多一些</span>
<span class="sd">    Args:</span>
<span class="sd">        dataMatIn    数据集</span>
<span class="sd">        classLabels  类别标签</span>
<span class="sd">        C   松弛变量(常量值)，允许有些数据点可以处于分隔面的错误一侧。</span>
<span class="sd">            控制最大化间隔和保证大部分的函数间隔小于1.0这两个目标的权重。</span>
<span class="sd">            可以通过调节该参数达到不同的结果。</span>
<span class="sd">        toler   容错率</span>
<span class="sd">        maxIter 退出前最大的循环次数</span>
<span class="sd">        kTup    包含核函数信息的元组</span>
<span class="sd">    Returns:</span>
<span class="sd">        b       模型的常量值</span>
<span class="sd">        alphas  拉格朗日乘子</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># 创建一个 optStruct 对象</span>
    <span class="n">oS</span> <span class="o">=</span> <span class="n">optStruct</span><span class="p">(</span><span class="n">mat</span><span class="p">(</span><span class="n">dataMatIn</span><span class="p">),</span> <span class="n">mat</span><span class="p">(</span><span class="n">classLabels</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">(),</span> <span class="n">C</span><span class="p">,</span> <span class="n">toler</span><span class="p">,</span> <span class="n">kTup</span><span class="p">)</span>
    <span class="nb">iter</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">entireSet</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="n">alphaPairsChanged</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># 循环遍历：循环maxIter次 并且 （alphaPairsChanged存在可以改变 or 所有行遍历一遍）</span>
    <span class="k">while</span> <span class="p">(</span><span class="nb">iter</span> <span class="o">&lt;</span> <span class="n">maxIter</span><span class="p">)</span> <span class="ow">and</span> <span class="p">((</span><span class="n">alphaPairsChanged</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">entireSet</span><span class="p">)):</span>
        <span class="n">alphaPairsChanged</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1">#  当entireSet=true or 非边界alpha对没有了；就开始寻找 alpha对，然后决定是否要进行else。</span>
        <span class="k">if</span> <span class="n">entireSet</span><span class="p">:</span>
            <span class="c1"># 在数据集上遍历所有可能的alpha</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">oS</span><span class="o">.</span><span class="n">m</span><span class="p">):</span>
                <span class="c1"># 是否存在alpha对，存在就+1</span>
                <span class="n">alphaPairsChanged</span> <span class="o">+=</span> <span class="n">innerL</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">oS</span><span class="p">)</span>
                <span class="c1"># print(&quot;fullSet, iter: %d i:%d, pairs changed %d&quot; % (iter, i, alphaPairsChanged))</span>
            <span class="nb">iter</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># 对已存在 alpha对，选出非边界的alpha值，进行优化。</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># 遍历所有的非边界alpha值，也就是不在边界0或C上的值。</span>
            <span class="n">nonBoundIs</span> <span class="o">=</span> <span class="n">nonzero</span><span class="p">((</span><span class="n">oS</span><span class="o">.</span><span class="n">alphas</span><span class="o">.</span><span class="n">A</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">oS</span><span class="o">.</span><span class="n">alphas</span><span class="o">.</span><span class="n">A</span> <span class="o">&lt;</span> <span class="n">C</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">nonBoundIs</span><span class="p">:</span>
                <span class="n">alphaPairsChanged</span> <span class="o">+=</span> <span class="n">innerL</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">oS</span><span class="p">)</span>
                <span class="c1"># print(&quot;non-bound, iter: %d i:%d, pairs changed %d&quot; % (iter, i, alphaPairsChanged))</span>
            <span class="nb">iter</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># 如果找到alpha对，就优化非边界alpha值，否则，就重新进行寻找，如果寻找一遍 遍历所有的行还是没找到，就退出循环。</span>
        <span class="k">if</span> <span class="n">entireSet</span><span class="p">:</span>
            <span class="n">entireSet</span> <span class="o">=</span> <span class="bp">False</span>  <span class="c1"># toggle entire set loop</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">alphaPairsChanged</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">entireSet</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;iteration number: </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">iter</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">oS</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="n">oS</span><span class="o">.</span><span class="n">alphas</span>
</pre></div>

<blockquote>
<p>测试算法：便携一个函数来测试不同的和函数并计算错误率</p>
</blockquote>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">testDigits</span><span class="p">(</span><span class="n">kTup</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;rbf&#39;</span><span class="p">,</span> <span class="mi">10</span><span class="p">)):</span>

    <span class="c1"># 1. 导入训练数据</span>
    <span class="n">dataArr</span><span class="p">,</span> <span class="n">labelArr</span> <span class="o">=</span> <span class="n">loadImages</span><span class="p">(</span><span class="s1">&#39;input/6.SVM/trainingDigits&#39;</span><span class="p">)</span>
    <span class="n">b</span><span class="p">,</span> <span class="n">alphas</span> <span class="o">=</span> <span class="n">smoP</span><span class="p">(</span><span class="n">dataArr</span><span class="p">,</span> <span class="n">labelArr</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mf">0.0001</span><span class="p">,</span> <span class="mi">10000</span><span class="p">,</span> <span class="n">kTup</span><span class="p">)</span>
    <span class="n">datMat</span> <span class="o">=</span> <span class="n">mat</span><span class="p">(</span><span class="n">dataArr</span><span class="p">)</span>
    <span class="n">labelMat</span> <span class="o">=</span> <span class="n">mat</span><span class="p">(</span><span class="n">labelArr</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
    <span class="n">svInd</span> <span class="o">=</span> <span class="n">nonzero</span><span class="p">(</span><span class="n">alphas</span><span class="o">.</span><span class="n">A</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">sVs</span> <span class="o">=</span> <span class="n">datMat</span><span class="p">[</span><span class="n">svInd</span><span class="p">]</span>
    <span class="n">labelSV</span> <span class="o">=</span> <span class="n">labelMat</span><span class="p">[</span><span class="n">svInd</span><span class="p">]</span>
    <span class="c1"># print(&quot;there are %d Support Vectors&quot; % shape(sVs)[0])</span>
    <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">shape</span><span class="p">(</span><span class="n">datMat</span><span class="p">)</span>
    <span class="n">errorCount</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
        <span class="n">kernelEval</span> <span class="o">=</span> <span class="n">kernelTrans</span><span class="p">(</span><span class="n">sVs</span><span class="p">,</span> <span class="n">datMat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:],</span> <span class="n">kTup</span><span class="p">)</span>
        <span class="c1"># 1*m * m*1 = 1*1 单个预测结果</span>
        <span class="n">predict</span> <span class="o">=</span> <span class="n">kernelEval</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">multiply</span><span class="p">(</span><span class="n">labelSV</span><span class="p">,</span> <span class="n">alphas</span><span class="p">[</span><span class="n">svInd</span><span class="p">])</span> <span class="o">+</span> <span class="n">b</span>
        <span class="k">if</span> <span class="n">sign</span><span class="p">(</span><span class="n">predict</span><span class="p">)</span> <span class="o">!=</span> <span class="n">sign</span><span class="p">(</span><span class="n">labelArr</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span> <span class="n">errorCount</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;the training error rate is: </span><span class="si">%f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">errorCount</span><span class="p">)</span> <span class="o">/</span> <span class="n">m</span><span class="p">))</span>

    <span class="c1"># 2. 导入测试数据</span>
    <span class="n">dataArr</span><span class="p">,</span> <span class="n">labelArr</span> <span class="o">=</span> <span class="n">loadImages</span><span class="p">(</span><span class="s1">&#39;input/6.SVM/testDigits&#39;</span><span class="p">)</span>
    <span class="n">errorCount</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">datMat</span> <span class="o">=</span> <span class="n">mat</span><span class="p">(</span><span class="n">dataArr</span><span class="p">)</span>
    <span class="n">labelMat</span> <span class="o">=</span> <span class="n">mat</span><span class="p">(</span><span class="n">labelArr</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
    <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">shape</span><span class="p">(</span><span class="n">datMat</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
        <span class="n">kernelEval</span> <span class="o">=</span> <span class="n">kernelTrans</span><span class="p">(</span><span class="n">sVs</span><span class="p">,</span> <span class="n">datMat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:],</span> <span class="n">kTup</span><span class="p">)</span>
        <span class="c1"># 1*m * m*1 = 1*1 单个预测结果</span>
        <span class="n">predict</span> <span class="o">=</span> <span class="n">kernelEval</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">multiply</span><span class="p">(</span><span class="n">labelSV</span><span class="p">,</span> <span class="n">alphas</span><span class="p">[</span><span class="n">svInd</span><span class="p">])</span> <span class="o">+</span> <span class="n">b</span>
        <span class="k">if</span> <span class="n">sign</span><span class="p">(</span><span class="n">predict</span><span class="p">)</span> <span class="o">!=</span> <span class="n">sign</span><span class="p">(</span><span class="n">labelArr</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span> <span class="n">errorCount</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;the test error rate is: </span><span class="si">%f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">errorCount</span><span class="p">)</span> <span class="o">/</span> <span class="n">m</span><span class="p">))</span>
</pre></div>

<blockquote>
<p>使用算法：一个图像识别的完整应用还需要一些图像处理的知识，这里并不打算深入介绍</p>
</blockquote>
<p><a href="https://github.com/apachecn/MachineLearning/blob/master/src/python/6.SVM/svm-complete.py">完整代码地址</a>: <a href="https://github.com/apachecn/MachineLearning/blob/master/src/python/6.SVM/svm-complete.py">https://github.com/apachecn/MachineLearning/blob/master/src/python/6.SVM/svm-complete.py</a></p>
<hr />
<ul>
<li><strong>作者：<a href="http://cwiki.apachecn.org/display/~jiangzhonglian">片刻</a> <a href="http://cwiki.apachecn.org/display/~houfachao">geekidentity</a></strong></li>
<li><a href="https://github.com/apachecn/MachineLearning">GitHub地址</a>: <a href="https://github.com/apachecn/MachineLearning">https://github.com/apachecn/MachineLearning</a></li>
<li><strong>版权声明：欢迎转载学习 =&gt; 请标注信息来源于 <a href="http://www.apachecn.org/">ApacheCN</a></strong></li>
</ul></div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script>var base_url = '../..';</script>
        <script src="../../js/base.js"></script>
        <script src="../../javascripts/extra.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML"></script>
        <script src="../../search/require.js"></script>
        <script src="../../search/search.js"></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="Search Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                <h4 class="modal-title" id="exampleModalLabel">Search</h4>
            </div>
            <div class="modal-body">
                <p>
                    From here you can search these documents. Enter
                    your search terms below.
                </p>
                <form role="form">
                    <div class="form-group">
                        <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query">
                    </div>
                </form>
                <div id="mkdocs-search-results"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="Keyboard Shortcuts Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                <h4 class="modal-title" id="exampleModalLabel">Keyboard Shortcuts</h4>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td><kbd>&larr;</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td><kbd>&rarr;</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>


    </body>
</html>
